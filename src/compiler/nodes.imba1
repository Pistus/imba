# imba$inlineHelpers=1
# imba$v2=0
# TODO Create Expression - make all expressions inherit from these?

var helpers = require './helpers'
var constants = require './constants'
var csscompiler = require './css'

import ImbaParseError from './errors'
import Token from './token'
import SourceMap from './sourcemap'

var HTML_TAGS = "a abbr address area article aside audio b base bdi bdo big blockquote body br button canvas caption cite code col colgroup data datalist dd del details dfn div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hr html i iframe img input ins kbd keygen label legend li link main map mark menu menuitem meta meter nav noscript object ol optgroup option output p param pre progress q rp rt ruby s samp script section select small source span strong style sub summary sup table tbody td textarea tfoot th thead time title tr track u ul var video wbr".split(" ")
var HTML_TAGS_UNSAFE = "article aside header section".split(" ")

var HTML_ATTRS =
	a: "href target hreflang media download rel type ping referrerpolicy"
	audio: "autoplay controls crossorigin loop muted preload src"
	area: "alt coords download href hreflang ping referrerpolicy rel shape target"
	base: "href target"
	video: "autoplay buffered controls crossorigin height loop muted preload poster src width playsinline"
	fieldset: "disabled form name"
	form: "method action enctype autocomplete target"
	button: "autofocus type form formaction formenctype formmethod formnovalidate formtarget value name"
	embed: "height src type width"
	input: "accept disabled form list max maxlength min minlength pattern required size step type"
	label: "accesskey for form"
	img: "alt src srcset crossorigin decoding height importance intrinsicsize ismap referrerpolicy sizes width usemap"
	link: "rel type href media"
	iframe: "allow allowfullscreen allowpaymentrequest height importance name referrerpolicy sandbox src srcdoc width frameborder align longdesc scrolling"
	meta: "property content charset desc http-equiv color-scheme name scheme"
	map: "name"
	optgroup: "label"
	option: "label"
	output: "for form"
	object: "type data width height"
	param: "name type value valuetype"
	progress: "max"
	script: "src type async defer crossorigin integrity nonce language nomodule"
	select: "size form multiple"
	source: "sizes src srcset type media"
	textarea: "rows cols minlength maxlength form wrap"
	track: "default kind label src srclang"
	td: "colspan rowspan headers"
	th: "colspan rowspan"

var HTML_PROPS =
	input: "autofocus autocomplete autocapitalize autocorrect value placeholder required disabled multiple checked readOnly spellcheck"
	textarea: "autofocus autocomplete autocapitalize autocorrect value placeholder required disabled multiple checked readOnly spellcheck"
	form: "novalidate"
	fieldset: "disabled"
	button: "disabled"
	select: "autofocus disabled required readOnly multiple"
	option: "disabled selected value"
	optgroup: "disabled"
	progress: "value"
	fieldset: "disabled"
	canvas: "width height"

export var AST = {}

var TREE_TYPE =
	DYNAMIC: 1
	STATIC: 2
	SINGLE: 3
	OPTLOOP: 4
	LOOP: 5

export var F = 
	TAG_INITED: 2 ** 0 
	TAG_CUSTOM: 2 ** 2
	TAG_AWAKENED: 2 ** 3
	TAG_MOUNTED: 2 ** 4
	TAG_SCHEDULE: 2 ** 5
	TAG_SCHEDULED: 2 ** 6
	TAG_FIRST_CHILD: 2 ** 7
	TAG_LAST_CHILD: 2 ** 8
	TAG_HAS_DYNAMIC_FLAGS: 2 ** 9
	TAG_HAS_BRANCHES: 2 ** 10
	TAG_HAS_LOOPS: 2 ** 11
	TAG_HAS_DYNAMIC_CHILDREN: 2 ** 12
	TAG_IN_BRANCH: 2 ** 13
	TAG_BIND_MODEL: 2 ** 14
	TAG_INDEXED: 2 ** 15
	TAG_KEYED: 2 ** 16

	# render marks
	DIFF_BUILT: 2 ** 0
	DIFF_FLAGS: 2 ** 1
	DIFF_ATTRS: 2 ** 2
	DIFF_CHILDREN: 2 ** 3


# Helpers for operators
export var OP = do |op, l, r|
	var o = String(op)
	switch o
		when '.'
			r = Identifier.new(r) if r isa String
			# r = r.value if r isa VarOrAccess
			Access.new(op,l,r)
		when '='
			Assign.new(op,l,r)

		when '?=','||=','&&='
			ConditionalAssign.new(op,l,r)
		when '+=','-=','*=','/=','^=','%=','**='
			CompoundAssign.new(op,l,r)

		when '?.'
			if r isa VarOrAccess
				r = r.value

			# depends on the right side - this is wrong
			PropertyAccess.new(op,l,r)

		when 'instanceof','isa'
			InstanceOf.new(op,l,r)
		when 'in'
			In.new(op,l,r)
		when 'typeof'
			TypeOf.new(op,l,r)
		when 'delete'
			Delete.new(op,l,r)
		when '--','++','!','âˆš','not' # alias
			UnaryOp.new(op,l,r)
		when '>','<','>=','<=','==','===','!=','!=='
			ComparisonOp.new(op,l,r)
		when '..','...'
			Range.new(op,l,r)
		else
			Op.new(op,l,r)

export var OP_COMPOUND = do |sym,op,l,r|
	# console.log "?. soak operator",sym
	if sym == '?.'
		console.log "?. soak operator"
		return null
	if sym == '?=' or sym == '||=' or sym == '&&='
		return ConditionalAssign.new(op,l,r)
	else
		return CompoundAssign.new(op,l,r)

var PATHIFY = do |val|
	if val isa TagAttrValue
		val = val.value

	if val isa ArgList
		val = val.values[0]
		
	while val isa Parens
		val = val.value
	
	if val isa VarOrAccess
		val = val.@variable or val.value
	# console.log "TagData value {val}"

	if val isa Access
		let left = val.left
		let right = val.right isa Index ? val.right.value : val.right

		if left isa VarOrAccess
			left = left.@variable or left.value

		if right isa VarOrAccess
			right = right.@variable or right.value
		
		if val isa IvarAccess
			left ||= val.scope__.context

		if right isa Identifier
			right = helpers.singlequote(String(right.js))
			right = Str.new(right)
		
		return [left,right]

	return val

var OPTS = {}
var ROOT = null

export var NODES = []

var LIT = do |val|
	Literal.new(val)

var SYM = do |val|
	Symbol.new(val)

var IF = do |cond,body,alt|
	var node = If.new(cond,body)
	node.addElse(alt) if alt
	node

var FN = do |pars,body|
	Func.new(pars,body)

var CALL = do |callee,pars = []|
	# possibly return instead(!)
	Call.new(callee,pars)

var CALLSELF = do |name,pars = []|
	var ref = Identifier.new(name)
	Call.new(OP('.',SELF,ref),pars)

var BLOCK = do
	Block.wrap([]:slice.call(arguments))

var WHILE = do |test,code|
	While.new(test).addBody(code)

export var SPLAT = do |value|
	Splat.new(value)
	# if value isa Assign
	#	value.left = Splat.new(value.left)
	#	return value
	# else
	#	Splat.new(value)

var SEMICOLON_TEST = /;(\s*\/\/.*)?[\n\s\t]*$/
var RESERVED_TEST = /^(default|char|for)$/

# captures error from parser
export def parseError str, o
	# find nearest token
	var err

	if o:lexer
		var token = o:lexer:yytext
		# console.log o:lexer:pos,token.@loc
		err = ImbaParseError.new({message: str},{
			pos: o:lexer:pos
			tokens: o:lexer:tokens
			token: o:lexer:yytext
			meta: o
		})

		throw err

		# should find the closest token with actual position
		# str = "[{token.@loc}:{token.@len || String(token):length}] {str}"
	var e = Error.new(str)
	e:lexer = o:lexer
	e:options = o
	throw e

def AST.c obj
	typeof obj == 'string' ? obj : obj.c

def AST.compileRaw item
	let o = ''
	if item isa Array
		o = '['
		for v in item
			o += AST.compileRaw(v) + ','
		o = o.slice(0,-1) + ']'

	elif item isa Object
		o = '{'
		for own k,v of item
			# maybe quote?
			o =+ "{k}:{AST.compileRaw(v)},"
		o = o.slice(0,-1) + '}'
	else
		o = JSON.stringify(item)
	return o

def AST.mark tok
	if tok and (OPTS:sourceMapInline or OPTS:sourceMap) and tok:sourceMapMarker
		tok.sourceMapMarker
	else
		''

def AST.blk obj
	obj isa Array ? Block.wrap(obj) : obj

def AST.sym obj
	# console.log "sym {obj}"
	helpers.symbolize(String(obj))

def AST.cary ary
	ary.map(|v| typeof v == 'string' ? v : v.c )

def AST.dump obj, key
	if obj isa Array
		obj.map do |v| v && v:dump ? v.dump(key) : v
	elif obj and obj:dump
		obj.dump

def AST.compact ary
	if ary isa ListNode
		return ary.compact


	ary.filter do |v| v != undefined && v != null

def AST.reduce res,ary
	for v in ary
		v isa Array ? AST.reduce(res,v) : res.push(v)
	return

def AST.flatten ary, compact = no
	var out = []
	for v in ary
		v isa Array ? AST.reduce(out,v) : out.push(v)
	return out

def AST.loc item
	if !item
		[0,0]
	elif item isa Token
		item.region
	elif item isa Node
		item.loc
	
def AST.parse str, opts = {}
	var indent = str.match(/\t+/)[0]
	# really? Require the compiler, not this
	Imbac.parse(str,opts)

def AST.inline str, opts = {}
	parse(str,opts).body

def AST.node typ, pars
	if typ == 'call'
		if pars[0].c == 'return'
			pars[0] = 'tata'
		Call.new(pars[0],pars[1],pars[2])

def AST.escapeComments str
	return '' unless str
	return str


var shortRefCache = []

def AST.counterToShortRef nr
	var base = "A".charCodeAt(0)

	while shortRefCache:length <= nr
		var num = shortRefCache:length + 1
		var str = ""

		while true
			num -= 1
			str = String.fromCharCode(base + (num % 26)) + str
			num = Math.floor(num / 26)
			break unless num > 0

		shortRefCache.push(str.toLowerCase())

	return shortRefCache[nr]

def AST.truthy node

	if node isa True
		return true

	if node isa False
		return false

	if node:isTruthy
		return node.isTruthy

	return undefined

export class Indentation

	prop open
	prop close

	def initialize a,b
		@open = a
		@close = b
		self

	def isGenerated
		@open and @open:generated

	def aloc
		@open and @open.@loc or 0

	def bloc
		@close and @close.@loc or 0

	def wrap str
		var om = @open and @open.@meta
		var pre = om and om:pre or ''
		var post = om and om:post or ''
		var esc = AST:escapeComments
		var out = @close

		# the first newline should not be indented?
		str = post.replace(/^\n/,'') + str
		str = str.replace(/^/g,"\t").replace(/\n/g,"\n\t").replace(/\n\t$/g,"\n")

		str = pre + '\n' + str
		str += out.c if out isa Terminator
		str = str + '\n' unless str[str:length - 1] == '\n'
		return str

var INDENT = Indentation.new({},{})

class Stash

	def initialize
		@entities = []

	def add item
		@entities.unshift(item)
		self

	def pluck item
		var match = null
		for entity,i in @entities
			if entity == item or entity isa item
				match = entity
				@entities.splice(i,1)
				return match
		return null


export class Stack

	prop loglevel
	prop nodes
	prop scopes

	def initialize
		reset

	def reset
		@nodes    = []
		@scoping  = []
		@scopes   = []
		@stash    = Stash.new(self)
		@loglevel = 3
		@counter  = 0
		@counters = {}
		@options = {}
		@es6 = null
		@es5 = null
		@optlevel = null
		@tag = null
		self

	def incr name
		@counters[name] ||= 0
		@counters[name] += 1

	def decr name
		@counters[name] ||= 0
		@counters[name] -= 1

	def generateId ns = 'oid'
		AST.counterToShortRef(STACK.incr('oid'))

	def stash
		@stash

	def option key
		@options and @options[key]

	def platform
		@options:target

	def filename
		@options:filename

	def sourcePath
		@options:sourcePath

	def es6
		@es6 ?= !!(@options:es6 or @options:es2015 or env('IMBA_ES6'))

	def es5
		@es5 ?= !!(@options:es5 or env('IMBA_ES5'))

	def autocall
		!option(:explicitParens)
		# !@options:explicitParens
		
	def optlevel
		@optlevel ?= (@options:conservative or env('IMBA_CONSERVATIVE') ? 0 : (@options:optlevel or 9)) # stack.option(:conservative)

	def env key
		var val = @options["ENV_{key}"]
		return val if val != undefined

		if F[key] != undefined
			return F[key]
		
		var lowercased = key.toLowerCase
		
		if @options[lowercased] != undefined
			return @options[lowercased]

		# temporary shorthand
		if lowercased == 'es6'
			return self.es6

		if lowercased == 'es5'
			return self.es5

		if platform and key in ['WEB','NODE','WEBWORKER']
			return platform.toUpperCase == key

		# console.log 'lookup env var',key,@options:env

		if var e = @options:env
			if e.hasOwnProperty(key)
				return e[key]
			elif e.hasOwnProperty(key.toLowerCase)
				return e[key.toLowerCase]

		if $node$ and typeof process != 'undefined' and process:env
			val = process:env[key.toUpperCase]
			if val != undefined
				return val
			return null

		return undefined	


	def addScope scope
		@scopes.push(scope)
		self

	def traverse node
		self

	def push node
		@nodes.push(node)
		# not sure if we have already defined a scope?
		self

	def pop node
		@nodes.pop # (node)
		self

	def parent
		@nodes[@nodes:length - 2]

	def current
		@nodes[@nodes:length - 1]

	def up test
		test ||= do |v| !(v isa VarOrAccess)

		var i = @nodes:length - 2 # key

		if test:prototype isa Node
			while i >= 0
				var node = @nodes[i--]
				return node if node isa test
			return null

		while i >= 0
			var node = @nodes[i]
			return node if test(node)
			i -= 1
		return null

	def relative node, offset = 0
		var idx = @nodes.indexOf(node)
		idx >= 0 ? @nodes[idx + offset] : null

	def scope lvl = 0
		var i = @nodes:length - 1 - lvl
		while i >= 0
			var node = @nodes[i]
			return node.@scope if node.@scope
			i -= 1
		return null

	def scopes
		# include deeper scopes as well?
		var scopes = []
		var i = @nodes:length - 1
		while i >= 0
			var node = @nodes[i]
			scopes.push(node.@scope) if node.@scope
			i -= 1
		return scopes

	def method
		up(MethodDeclaration)

	def block
		up(Block)

	def blockpart
		up do |node| relative(node,-1) isa Block

	def isExpression
		var i = @nodes:length - 1
		while i >= 0
			var node = @nodes[i]
			# why are we not using isExpression here as well?
			if node isa Code or node isa Loop
				return false
			if node.isExpression
				return true
			# probably not the right test - need to be more explicit
			i -= 1
		return false

	def toString
		"Stack({@nodes.join(" -> ")})"

	def isAnalyzing
		@analyzing

	def scoping
		@nodes.filter(|n| n.@scope ).map(|n| n.@scope )

# Lots of globals -- really need to deal with one stack per file / context
export var STACK = Stack.new

# use a bitmask for these

export class Node

	prop o
	prop options
	prop traversed

	def safechain
		no

	def oid
		@oid ||= STACK.generateId('')

	def p
		# allow controlling this from CLI
		if STACK.loglevel > 0
			console.log(*arguments)
		self

	def typeName
		self:constructor:name

	def namepath
		typeName

	def initialize
		setup
		self

	def setup
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@value = null
		self

	def set obj
		@options ||= {}
		for own k,v of obj
			@options[k] = v
		self

	# get and set
	def option key, val
		if val != undefined
			@options ||= {}
			@options[key] = val
			return self

		@options && @options[key]

	def keyword
		option(:keyword)

	def configure obj
		set(obj)

	def region
		[0,0]

	def loc
		[0,0]

	def token
		null

	def compile
		self

	def visit
		self

	def stack
		STACK

	def isString
		no

	def isPrimitive deep
		no

	def isReserved
		no

	# should rather do traversals
	# o = {}, up, key, index
	def traverse
		if @traversed
			return self
		# NODES.push(self)
		@traversed = yes
		STACK.push self
		visit(STACK)
		STACK.pop self
		return self

	def inspect
		{type: self:constructor.toString}

	def js o
		"NODE"

	def toString
		"{self:constructor:name}"

	# swallow might be better name
	def consume node
		if node isa TagLike
			return node.register(self)

		if node isa PushAssign
			node.register(self)
			return PushAssign.new(node.op,node.left,self)

		if node isa Assign
			# node.right = self
			return OP(node.op,node.left,self)
		elif node isa Op
			return OP(node.op,node.left,self)
		elif node isa Return
			return Return.new(self)
		return self

	def toExpression
		@expression = true
		self

	def forceExpression
		@expression = true
		self

	def isExpressable
		true

	def isExpression
		@expression || false

	def hasSideEffects
		true

	def isUsed
		true

	def shouldParenthesize
		false

	def shouldParenthesizeInTernary
		yes

	def block
		Block.wrap([self])

	def node
		self

	def scope__
		STACK.scope

	def up
		STACK.parent

	def util
		Util

	def receiver
		self

	def addExpression expr
		# might be better to nest this up after parsing is done?
		var node = ExpressionBlock.new([self])
		return node.addExpression(expr)


	def indented a,b

		if a isa Indentation
			@indentation = a
			return self

		# this is a _BIG_ hack
		if b isa Array
			add(b[0])
			b = b[1]

		# if indent and indent.match(/\:/)
		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		self

	def prebreak term = '\n'
		self

	def invert
		return OP('!',self)

	def cache o = {}
		@cache = o
		o:var = (o:scope or scope__).temporary(self,o)
		o:lookups = 0
		self

	def cachevar
		@cache && @cache:var

	def decache
		if @cache
			cachevar.free
			@cache = null
		self

	# the "name-suggestion" for nodes if they need to be cached
	def alias
		null

	def warn text, opts = {}
		opts:message = text
		opts:loc ||= loc
		scope__.root.warn opts
		self

	def c o
		var s = STACK
		var ch = @cache
		return c_cached(ch) if ch and ch:cached

		s.push(self)
		forceExpression if o && o:expression

		if o and o:indent
			@indentation ||= INDENT

		var out = js(s,o)

		# really? why not call this somewhere else?
		var paren = shouldParenthesize

		if var indent = @indentation
			out = indent.wrap(out,o)

		# should move this somewhere else really
		out = "({out})" if paren
		if (o and o:braces) or (@options and @options:braces)
			if indent
				out = '{' + out + '}'
			else
				out = '{ ' + out + ' }'

		s.pop(self)

		if ch = @cache
			out = "{ch:var.c} = {out}" unless ch:manual
			var par = s.current
			out = '(' + out + ')' if par isa Access || par isa Op # others? #
			ch:cached = yes
		return out

	def c_cached cache
		cache:lookups++
		cache:var.free if cache:uses == cache:lookups
		return cache:var.c # recompile every time??

export class ValueNode < Node

	prop value

	def initialize value
		setup
		@value = load(value)

	def load value
		value

	def js o
		typeof @value == 'string' ? @value : @value.c

	def visit

		@value.traverse if @value isa Node #  && @value:traverse
		self

	def region
		[@value.@loc,@value.@loc + @value.@len]

export class AssertionNode < ValueNode
	def js o
		let op = @value
		let out = []

		if op isa Op and !(op isa Access)
			let l = op.left
			let r = op.right

			out.push(l.cache.c(o))
			out.push(helpers.singlequote(op.@op))
			out.push(r.cache.c(o))
			out = ["imba.$a=[{out.join(',')}]"]
			out.push(op.c(o))
			# op.cache
			# out.push('imba.$asrt=undefined')
			# out.push(op.c(o))
		else
			out.push('imba.$a=null')
			out.push(op.c(o))
		return '(' + out.join(',') + ")" # ,{op.c(o)})
		# "('assert',{super})"

export class Statement < ValueNode

	def isExpressable
		return no


export class Meta < ValueNode

	def isPrimitive deep
		yes

export class Comment < Meta

	def visit
		if @value.type == 'HERECOMMENT'
			
			let raw = @value.@value
			let line = raw.slice(0,raw.indexOf('\n')).trim

			if let m = line.match(/^(css|less|stylus|sass|scss)( scoped)?/)
				var style = {
					content: raw.slice(raw.indexOf('\n'))
					scoped: !!m[2]
					type: m[1]
					attrs: {}
				}
				scope__.root.styles.push(style)

		if var block = up
			var idx = block.indexOf(self) + 1
			idx += 1 if block.index(idx) isa Terminator
			if var next = block.index(idx)
				next.@desc = self

		self

	def toDoc
		helpers.normalizeIndentation("" + @value.@value)

	def toJSON
		helpers.normalizeIndentation("" + @value.@value)

	def c o
		return "" if STACK.option(:comments) == false
		var v = @value.@value
		if o and o:expression or v.match(/\n/) or @value.type == 'HERECOMMENT' # multiline?
			"/*{v}*/"
		else
			"// {v}"

export class Terminator < Meta

	def initialize v
		@value = v
		self

	def traverse
		self

	def loc
		[@value.@loc,@value.@loc + @value.@value:length]

	def c
		let val = @value.c
		if STACK.option(:comments) == false
			val = val.replace(/\/\/.*$/gm,'')
		return val

export class Newline < Terminator

	def initialize v
		@traversed = no
		@value = v or '\n'

	def c
		AST.c(@value)


# weird place?
export class Index < ValueNode

	def cache o = {}
		@value.cache(o)

	def js o
		@value.c

export class ListNode < Node

	prop nodes

	def initialize list
		setup
		@nodes = load(list or [])
		@indentation = null

	# PERF acces @nodes directly?
	def list
		@nodes

	def compact
		@nodes = AST.compact(@nodes)
		self

	def load list
		list

	def concat other
		# need to store indented content as well?
		@nodes = nodes.concat(other isa Array ? other : other.nodes)
		self

	def swap item, other
		var idx = indexOf(item)
		nodes[idx] = other if idx >= 0
		self

	def push item
		@nodes.push(item)
		self

	def pop
		var end = @nodes.pop
		return end

	def add item
		@nodes.push(item)
		self

	def unshift item, br
		@nodes.unshift(BR) if br
		@nodes.unshift(item)
		self

	# test
	def slice a, b
		self:constructor.new(@nodes.slice(a,b))

	def break br, pre = no
		br = Terminator.new(br) if typeof br == 'string'
		pre ? unshift(br) : push(br)
		self

	def some cb
		for node in @nodes
			return yes if cb(node)
		return no

	def every cb
		for node in @nodes
			return no unless cb(node)
		return yes
	
	# filtered list of items
	def values
		@nodes.filter do |item| !(item isa Meta)

	def filter cb
		@nodes.filter(cb)

	def pluck cb
		var item = filter(cb)[0]
		remove(item) if item
		return item

	def indexOf item
		@nodes.indexOf(item)

	def index i
		@nodes[i]

	def remove item
		var idx = @nodes.indexOf(item)
		@nodes.splice(idx, 1) if idx >= 0
		self

	def removeAt idx
		var item = @nodes[idx]
		@nodes.splice(idx, 1) if idx >= 0
		return item


	def replace original, replacement
		var idx = @nodes.indexOf(original)
		if idx >= 0
			if replacement isa Array
				@nodes.splice(idx,1,*replacement)
			else
				@nodes[idx] = replacement
		self

	def first
		@nodes[0]

	def last
		var i = @nodes:length
		while i
			i = i - 1
			var v = @nodes[i]
			return v unless v isa Meta
		return null

	def map fn
		@nodes.map(fn)

	def forEach fn
		@nodes.forEach(fn)

	def remap fn
		@nodes = map(fn)
		self

	def count
		@nodes:length

	def realCount
		var k = 0
		for node in @nodes
			k++ if node and !(node isa Meta)
		return k

	def visit
		for node in @nodes
			node and node.traverse
		self

	def isExpressable
		for node in nodes
			return no if node and !node.isExpressable

		return yes

	def toArray
		@nodes

	def delimiter
		@delimiter or ","

	def js o, nodes: @nodes
		var delim = ','
		var express = delim != ';'
		var last = last

		var i = 0
		var l = nodes:length
		var str = ""

		for arg in nodes
			var part = typeof arg == 'string' ? arg : (arg ? arg.c(expression: express) : '')
			str += part
			str += delim if part and (!express or arg != last) and !(arg isa Meta)

		return str

	def indented a,b
		if a isa Indentation
			@indentation = a
			return self

		@indentation ||= a and b ? Indentation.new(a,b) : INDENT
		self


export class ArgList < ListNode

	def consume node
		if node isa TagLike
			@nodes = @nodes.map do |child|
				if !(child isa Meta) and !(child isa Assign)
					child.consume(node)
				else
					child
			return self
		super

export class AssignList < ArgList

	def concat other
		if @nodes:length == 0 and other isa AssignList
			return other
		else
			super(other)
		# need to store indented content as well?
		# @nodes = nodes.concat(other isa Array ? other : other.nodes)
		self


export class Block < ListNode

	prop head

	def initialize list
		setup
		@nodes = list or []
		@head = null
		@indentation = null

	def self.wrap ary
		unless ary isa Array
			throw SyntaxError.new("what")
		ary:length == 1 && ary[0] isa Block ? ary[0] : Block.new(ary)

	def visit stack
		@scope.visit if @scope

		if stack and stack.@tag
			@tag = stack.@tag

		for node,i in @nodes
			node and node.traverse
		
		self

	def block
		self
		
	def collectDecorators
		if let decorators = @decorators
			@decorators = null
			return decorators

	def loc
		# rather indents, no?
		if var opt = option(:ends)
			var a = opt[0].loc
			var b = opt[1].loc

			p "no loc for {opt[0]}" unless a
			p "no loc for {opt[1]}" unless b

			return [a[0],b[1]]

		if var ind = @indentation
			if ind.aloc != -1
				return [ind.aloc,ind.bloc]

		let a = @nodes[0]
		let b = @nodes[@nodes:length - 1]

		[a and a.loc[0] or 0,b and b.loc[1] or 0]

	# go through children and unwrap inner nodes
	def unwrap
		var ary = []
		for node,i in nodes
			if node isa Block
				ary:push.apply(ary,node.unwrap)
			else
				ary.push(node)
		return ary

	def push item
		@nodes.push(item)
		self

	def add item
		if item isa Array
			@nodes.push(*item)
		else
			@nodes.push(item)
		self

	# This is just to work as an inplace replacement of nodes.coffee
	# After things are working okay we'll do bigger refactorings
	def compile o = {}
		var root = Root.new(self,o)
		root.compile(o)


	# Not sure if we should create a separate block?
	def analyze o = {}
		self

	def cpart node
		var out = typeof node == 'string' ? node : (node ? node.c : "")
		return "" if out == null or out == undefined or out == ""

		if out isa Array
			var str = ""
			var l = out:length
			var i = 0
			while i < l
				str += cpart(out[i++])
			return str

		var hasSemiColon = SEMICOLON_TEST.test(out)
		out += delimiter unless hasSemiColon or node isa Meta
		return out

	def delimiter
		@delimiter == undefined ? ';' : @delimiter

	def js o, opts
		var ast = @nodes
		var l = ast:length
		# really?
		var express = isExpression or o.isExpression or (option(:express) and isExpressable)
		return '' if ast:length == 0

		if express
			return super(o,nodes: ast)

		var str = ""

		for v in ast
			str += cpart(v)

		# now add the head items as well
		if @head and @head:length > 0
			var prefix = ""
			for v in @head
				var hv = cpart(v)
				prefix += hv + '\n' if hv
			str = prefix + str
			
		if option(:strict)
			str = cpart('"use strict";\n') + str

		return str


	# Should this create the function as well?
	def defers original, replacement
		var idx = @nodes.indexOf(original)
		@nodes[idx] = replacement if idx >= 0
		var rest = @nodes.splice(idx + 1)
		return rest

	def expressions
		var expressions = []
		for node in nodes
			expressions.push(node) unless node isa Terminator
		return expressions


	def consume node
		if node isa TagLike
			let real = expressions

			@nodes = @nodes.map do |child|
				if child in real and !(child isa Assign)
					child.consume(node)
				else
					child
			return self

		# can also return super if it is expressable, but should we really?
		if var before = last
			var after = before.consume(node)
			if after != before
				if after isa Block
					after = after.nodes

				replace(before,after)

		return self


	def isExpressable
		return no unless @nodes.every(|v| v.isExpressable )
		return yes

	def isExpression

		option(:express) || @expression

	def shouldParenthesizeInTernary
		if count == 1
			return first.shouldParenthesizeInTernary

		yes

export class ExpressionList < Block

export class VarDeclList < Block
	
	def type
		option(:type) or 'var'

	def add part
		push(BR) if @nodes:length
		let expr = VarReference.new(part[0],type).set(decl: self)
		push(part[1] ? Assign.new('=',expr,part[1]) : expr)

	def consume node
		return self

	# def js
	# 	let out = super


# this is almost like the old VarDeclarations but without the values
export class VarBlock < ListNode

	def load list
		var first = list[0]

		if first isa Assign
			@type = first.left.@type
		elif first isa VarReference
			@type = first.@type
		# @type = list[0] and list[0].type
		list

	# TODO All these inner items should rather be straight up literals
	# or basic localvars - without any care whatsoever about adding var to the
	# beginning etc.

	def add expr
		# console.log "add item to varBlock!",expr
		push(expr)
		# addExpression(expr)

	def addExpression expr

		if expr isa Assign
			# make sure the left-side is a var-reference
			# this should be a different type of assign, no?
			if expr.left isa VarOrAccess
				expr.left = VarReference.new(expr.left.value,@type)

			push(expr)

		elif expr isa VarOrAccess
			# this is really a VarReference
			push(VarReference.new(expr.value,@type))

		elif expr isa Splat && expr.node isa VarOrAccess
			expr.value = VarReference.new(expr.node.value,@type)
			push(expr)
		else
			p "VarBlock.addExpression {self} <- {expr}"
			throw "VarBlock does not allow non-variable expressions"
		self


	def isExpressable
		# we would need to force-drop the variables, makes little sense
		# but, it could be, could just push the variables out?
		no

	def js o
		var code = AST.compact(AST.flatten(AST.cary(nodes)))
		code = code.filter(|n| n != null && n != undefined && n != EMPTY)
		var out = code.join(",")

		# are we sure?
		var keyword = o.es5 ? 'var' : (@type or 'var')
		# we just need to trust that the variables have been autodeclared beforehand
		# if we are inside an expression
		out = "{keyword} " + out unless o.isExpression
		return out


	def consume node
		# It doesnt make much sense for a VarBlock to consume anything
		# it should probably return void for methods
		return self


# Could inherit from valueNode
export class Parens < ValueNode

	def initialize value, open, close
		setup
		@open = open
		@close = close
		@value = load(value)

	def load value
		@noparen = no
		value isa Block and value.count == 1 ? value.first : value

	def isString
		# checking if this is an interpolated string
		@open and String(@open) == '("' or value.isString

	def js o

		var par = up
		var v = @value
		var str = null

		@noparen = yes if v isa Func

		if par isa Block
			# is it worth it?
			@noparen = yes unless o.isExpression
			str = v isa Array ? AST.cary(v) : v.c(expression: o.isExpression)
		else
			str = v isa Array ? AST.cary(v) : v.c(expression: yes)

		# check if we really need parens here?
		return str

	def set obj
		console.log "Parens set {JSON.stringify(obj)}"
		super(obj)


	def shouldParenthesize
		# no need to parenthesize if this is a line in a block
		return no if @noparen #  or par isa ArgList
		return yes


	def prebreak br
		super(br)
		console.log "PREBREAK"
		@value.prebreak(br) if @value
		self


	def isExpressable
		@value.isExpressable

	def consume node
		@value.consume(node)


# Could inherit from valueNode
# an explicit expression-block (with parens) is somewhat different
# can be used to return after an expression
export class ExpressionBlock < ListNode


	def c o
		map(|item| item.c(o) ).join(",")

	def consume node
		value.consume(node)

	def addExpression expr
		push(expr)
		self



# STATEMENTS

export class Return < Statement

	prop value

	def initialize v
		@traversed = no
		@value = v isa ArgList and v.count == 1 ? v.last : v
		return self

	def visit
		@value.traverse if @value && @value:traverse

	def js o
		var v = @value

		if v isa ArgList
			return "return [{v.c(expression: yes)}]"
		elif v
			return "return {v.c(expression: yes)}"
		else
			"return"

	def c
		return super if !value or value.isExpressable
		value.consume(self).c

	def consume node
		return self

export class ImplicitReturn < Return

export class GreedyReturn < ImplicitReturn

# cannot live inside an expression(!)
export class Throw < Statement

	def js o
		"throw {value.c}"

	def consume node
		# ROADMAP should possibly consume to the value of throw and then throw?
		return self


export class LoopFlowStatement < Statement

	prop literal
	prop expression

	def initialize lit, expr
		self.literal = lit
		self.expression = expr

	def visit
		expression.traverse if expression

	def consume node
		self

	def c
		return super unless expression
		# get up to the outer loop
		var _loop = STACK.up(Loop)

		# need to fix the grammar for this. Right now it
		# is like a fake call, but should only care about the first argument
		var expr = self.expression

		if _loop.catcher
			expr = expr.consume(_loop.catcher)
			var copy = self:constructor.new(literal)
			Block.new([expr,copy]).c
		elif expr
			var copy = self:constructor.new(literal)
			Block.new([expr,copy]).c
		else
			super
		# return "loopflow"


export class BreakStatement < LoopFlowStatement
	def js o do "break"

export class ContinueStatement < LoopFlowStatement
	def js o do "continue"

export class DebuggerStatement < Statement


# PARAMS

export class Param < Node

	prop name
	prop index
	prop defaults
	prop splat
	prop variable
	prop value

	def initialize value, defaults, typ
		# could have introduced bugs by moving back to identifier here
		if typeof value == 'string'
			value = Identifier.new(value)

		@traversed = no
		@name = value
		@value = value
		@defaults = defaults
		@typ = typ
		@variable = null

	def varname
		@variable ? @variable.c : name

	def js o
		if @defaults
			return "{@value.c} = {@defaults.c}"
		elif option(:splat)
			return "..." + @value.c
		else
			return @value.c

		return @variable.c if @variable

	def visit
		@value.traverse if @value
		@defaults.traverse if @defaults
		self.variable ||= scope__.register(name,self)

		if @name isa Identifier
			# change type here?
			@name.@value.@type = "PARAMVAR" if @name.@value
			@name.references(@variable)
			@variable.addReference(@name)

		self

	def assignment
		OP('=',variable.accessor,defaults)

	def isExpressable
		!defaults || defaults.isExpressable

	def dump
		{loc: loc}

	def loc
		@name && @name.region

	def toJSON
		{
			type: typeName
			name: name
			defaults: defaults
		}

export class SplatParam < Param

	def loc
		# hacky.. cannot know for sure that this is right?
		var r = name.region
		[r[0] - 1,r[1]]

export class BlockParam < Param

	def c
		"blockparam"

	def loc
		# hacky.. cannot know for sure that this is right?
		var r = name.region
		[r[0] - 1,r[1]]


export class OptionalParam < Param

export class NamedParam < Param

export class RequiredParam < Param

export class NamedParams < ListNode

	prop index
	prop variable

	def load list
		var load = (|k| NamedParam.new(k.key,k.value) )
		list isa Obj ? list.value.map(load) : list

	def visit
		var s = scope__
		@variable ||= s.temporary(self, pool: 'keypars')
		@variable.predeclared

		# this is a listnode, which will automatically traverse
		# and visit all children
		super
		# register the inner variables as well(!)
		self


	def varname
		variable.c

	def name
		varname

	def js o
		"namedpar"

	def toJSON
		{
			type: typeName
			nodes: filter(|v| v isa NamedParam)
		}


export class IndexedParam < Param

	prop parent
	prop subindex

	def visit
		# BUG The defaults should probably be looked up like vars
		self.variable ||= scope__.register(name,self)
		self.variable.proxy(parent.variable,subindex)
		self


export class ArrayParams < ListNode

	prop index
	prop variable

	def visit
		var s = scope__
		@variable ||= s.temporary(self, pool: 'keypars')
		@variable.predeclared

		# now when we loop through these inner params - we create the pars
		# with the correct name, but bind them to the parent
		super

	def name
		variable.c

	def load list
		return null unless list isa Arr
		# try the basic first
		unless list.splat
			list.value.map do |v,i|
				# must make sure the params are supported here
				# should really not parse any array at all(!)
				var name = v
				if v isa VarOrAccess
					# FIX?
					name = v.value.value
					# this is accepted
				parse(name,v,i)

	def parse name,child,i
		var param = IndexedParam.new(name,null)

		param.parent = self
		param.subindex = i
		param

	def head ast
		self

export class ParamList < ListNode

	prop splat
	prop block

	def at index, force = no, name = null
		if force
			add(Param.new(count == index && name || "_{count}")) until count > index
			# need to visit at the same time, no?
		list[index]

	def metadata
		filter(|par| !(par isa Meta))

	def toJSON
		metadata

	def visit
		@splat = filter(|par| par isa SplatParam)[0]
		var blk = filter(|par| par isa BlockParam)

		if blk:length > 1
			blk[1].warn "a method can only have one &block parameter"

		elif blk[0] && blk[0] != last
			blk[0].warn "&block must be the last parameter of a method"
			# warn "&block must be the last parameter of a method", blk[0]

		# add more warnings later(!)
		# should probably throw error as well to stop compilation

		# need to register the required-pars as variables
		super

	def js o
		return EMPTY if count == 0

		if o.parent isa Block
			return head(o)

		# items = map(|arg| arg.name.c ).compact
		# return null unless items[0]

		if o.parent isa Code
			# return "params_here"
			# remove the splat, for sure.. need to handle the other items as well
			# this is messy with references to argvars etc etc. Fix
			var pars = nodes
			# pars = filter(|arg| arg != @splat && !(arg isa BlockParam)) if @splat
			# pars = filter(|arg| arg isa RequiredParam or arg isa OptionalParam) if @splat
			AST.compact(nodes.map(|param| param.c() )).join(",")
		else
			throw "not implemented paramlist js"
			"ta" + AST.compact(map(|arg| arg.c )).join(",")

	def head o
		var reg = []
		var opt = []
		var blk = null
		var splat = null
		var named = null
		var arys = []
		var signature = []
		var idx = 0

		nodes.forEach do |par,i|
			par.index = idx
			if par isa NamedParams
				signature.push('named')
				named = par
			elif par isa OptionalParam
				signature.push('opt')
				opt.push(par)
			elif par isa BlockParam
				signature.push('blk')
				blk = par
			elif par isa SplatParam
				signature.push('splat')
				splat = par
				idx -= 1 # this should really be removed from the list, no?
			elif par isa ArrayParams
				arys.push(par)
				signature.push('ary')
			else
				signature.push('reg')
				reg.push(par)
			idx++

		if named
			var namedvar = named.variable

		# var opt = nodes.filter(|n| n isa OptionalParam)
		# var blk = nodes.filter(|n| n isa BlockParam)[0]
		# var splat = nodes.filter(|n| n isa SplatParam)[0]

		# simple situation where we simply switch
		# can probably optimize by not looking at arguments at all
		var ast = []
		var isFunc = do |js| "typeof {js} == 'function'"

		# This is broken when dealing with iframes anc XSS scripting
		# but for now it is the best test for actual arguments
		# can also do constructor.name == 'Object'
		var isObj = do |js| "{js}.constructor === Object"
		var isntObj = do |js| "{js}.constructor !== Object"
		# should handle some common cases in a cleaner (less verbose) manner
		# does this work with default params after optional ones? Is that even worth anything?
		# this only works in one direction now, unlike TupleAssign

		# we dont really check the length etc now -- so it is buggy for lots of arguments

		# if we have optional params in the regular order etc we can go the easy route
		# slightly hacky now. Should refactor all of these to use the signature?
		if !named && !splat && !blk && opt:length > 0 && signature.join(" ").match(/opt$/)
			for par,i in opt
				ast.push "if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}"


		elif named && !splat && !blk && opt:length == 0 # and no block?!
			# different shorthands
			# if named
			ast.push "if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \{\}"

		elif blk && opt:length == 1 && !splat && !named
			var op = opt[0]
			var opn = op.name.c
			var bn = blk.name.c
			ast.push "if({bn}==undefined && {isFunc(opn)}) {bn} = {opn},{opn} = {op.defaults.c}"
			ast.push "if({opn}==undefined) {opn} = {op.defaults.c}"

		elif blk && named && opt:length == 0 && !splat
			var bn = blk.name.c
			ast.push "if({bn}==undefined && {isFunc(namedvar.c)}) {bn} = {namedvar.c},{namedvar.c} = \{\}"
			ast.push "else if(!{namedvar.c}||{isntObj(namedvar.c)}) {namedvar.c} = \{\}"

		elif opt:length > 0 || splat # && blk  # && !splat

			var argvar = scope__.temporary(self, pool: 'arguments').predeclared.c
			var len = scope__.temporary(self, pool: 'counter').predeclared.c

			var last = "{argvar}[{len}-1]"
			var pop = "{argvar}[--{len}]"
			ast.push "var {argvar} = arguments, {len} = {argvar}.length"

			if blk
				var bn = blk.name.c
				if splat
					ast.push "var {bn} = {isFunc(last)} ? {pop} : null"
				elif reg:length > 0
					# ast.push "// several regs really?"
					ast.push "var {bn} = {len} > {reg:length} && {isFunc(last)} ? {pop} : null"
				else
					ast.push "var {bn} = {isFunc(last)} ? {pop} : null"

			# if we have named params - look for them before splat
			# should probably loop through pars in the same order they were added
			# should it be prioritized above optional objects??
			if named
				# should not include it when there is a splat?
				ast.push "var {namedvar.c} = {last}&&{isObj(last)} ? {pop} : \{\}"

			for par,i in opt
				ast.push "if({len} < {par.index + 1}) {par.name.c} = {par.defaults.c}"

			# add the splat
			if splat
				var sn = splat.name.c
				var si = splat.index

				if si == 0
					ast.push "var {sn} = new Array({len}>{si} ? {len} : 0)"
					ast.push "while({len}>{si}) {sn}[{len}-1] = {pop}"
				else
					ast.push "var {sn} = new Array({len}>{si} ? {len}-{si} : 0)"
					ast.push "while({len}>{si}) {sn}[--{len} - {si}] = {argvar}[{len}]"

			# if named
			# 	for k,i in named.nodes
			# 		# OP('.',namedvar) <- this is the right way, with invalid names etc
			# 		var op = OP('.',namedvar,k.key).c
			# 		ast.push "var {k.key.c} = {op} !== undefined ? {op} : {k.value.c}"

			# if named

			# return ast.join(";\n") + ";"
			# return "if({opt[0].name.c} instanceof Function) {blk.c} = {opt[0].c};"


		elif opt:length > 0
			for par,i in opt
				ast.push "if({par.name.c} === undefined) {par.name.c} = {par.defaults.c}"

		# now set stuff if named params(!)

		if named
			for k,i in named.nodes
				# console.log "named var {k.c}"
				var op = OP('.',namedvar,k.c).c
				ast.push "var {k.c} = {op} !== undefined ? {op} : {k.defaults.c}"

		if arys:length
			for v,i in arys
				# create tuples
				v.head(o,ast,self)
				# ast.push v.c



		# if opt:length == 0
		return ast:length > 0 ? (ast.join(";\n") + ";") : EMPTY


# Legacy. Should move away from this?
export class VariableDeclaration < ListNode

	# for later, moz-ast style
	prop kind

	# we want to register these variables in
	def add name, init, pos = -1
		var vardec = VariableDeclarator.new(name,init)
		vardec.variable = name if name isa Variable
		pos == 0 ? unshift(vardec) : push(vardec)
		vardec

	def load list
		# temporary solution!!!
		list.map do |par| VariableDeclarator.new(par.name,par.defaults,par.splat)

	def isExpressable
		nodes.every(|item| item.isExpressable)

	def js o
		return EMPTY if count == 0

		# When is this needed?
		if count == 1 && !isExpressable
			first.variable.autodeclare
			var node = first.assignment
			return node.c

		
		var keyword = 'var'
		var groups = {}

		nodes.forEach do |item|
			let typ = item.@variable and item.@variable.type
			groups[typ] ||= []
			groups[typ].push(item.@variable)

		if groups['let'] and (groups['var'] or groups['const'])
			# console.warn "VariableDeclaration with both var and let",nodes.map(|v| v.@variable and v.@variable.c )
			groups['let'].forEach do |item| item.@virtual = yes
		elif groups['let'] and !o.es5
			keyword = 'let'

		# FIX PERFORMANCE
		var out = AST.compact(AST.cary(nodes)).join(", ")
		out ? "{keyword} {out}" : ""

export class VariableDeclarator < Param
	
	prop type
	# can possibly create the variable immediately but wait with scope-declaring
	# What if this is merely the declaration of a system/temporary variable?
	def visit
		# even if we should traverse the defaults as if this variable does not exist
		# we need to preregister it and then activate it later
		self.variable ||= scope__.register(name,null, type: @type or 'var')
		defaults.traverse if defaults
		# WARN what if it is already declared?
		self.variable.declarator = self
		self.variable.addReference(name)
		self

	# needs to be linked up to the actual scoped variables, no?
	def js o
		return null if variable.@proxy

		var defs = defaults
		# FIXME need to deal with var-defines within other statements etc
		# FIXME need better syntax for this
		if defs != null && defs != undefined
			# console.log "defaults is {defaults}"
			defs = defs.c(expression: yes) if defs isa Node

			"{variable.c} = {defs}"
		else
			"{variable.c}"

	def accessor
		self


# TODO clean up and refactor all the different representations of vars
# VarName, VarReference, LocalVarAccess?
export class VarName < ValueNode

	prop variable
	prop splat

	def initialize a,b
		super
		@splat = b

	def visit
		# should we not lookup instead?
		# FIXME p "register value {value.c}"
		self.variable ||= scope__.register(value.c,null)
		self.variable.declarator = self
		self.variable.addReference(value)
		self

	def js o
		variable.c

	def c
		variable.c


export class VarList < Node

	prop type # let / var / const
	prop left
	prop right

	# format :type, :left, :right

	# should throw error if there are more values on right than left

	def initialize t,l,r
		@traversed = no
		@type = type
		@left = l
		@right = r

	def visit

		# we need to carefully traverse children in the right order
		# since we should be able to reference
		for l,i in left
			l.traverse # this should really be a var-declaration
			r.traverse if var r = right[i]
		self

	def js o
		# for the regular items
		var pairs = []
		var ll = left:length
		var rl = right:length
		var v = null

		# splatting here we come
		if ll > 1 && rl == 1
			p "multiassign!"
			var r = right[0]
			r.cache
			for l,i in left
				if l.splat
					throw "not supported?"
					p "splat" # FIX reimplement slice?
					if i == ll - 1
						v = util.slice(r,i)
						p "last"
					else
						v = util.slice(r,i,-(ll - i) + 1)
				else
					v = OP('.',r,Num.new(i))

				pairs.push(OP('=',l,v))

		else
			for l,i in left
				var r = right[i]
				pairs.push(r ? OP('=',l.variable.accessor,r) : l)

		return "var {pairs.c}"


# CODE

export class Code < Node

	prop head
	prop body
	prop scope
	prop params

	def scopetype
		Scope

	def visit
		@scope.visit if @scope
		# @scope.parent = STACK.scope(1) if @scope
		self


# Rename to Program?
export class Root < Code

	def initialize body, opts
		@traversed = no
		@body = AST.blk(body)
		@scope = RootScope.new(self,null)
		@options = {}

	def loc
		@body.loc

	def visit
		ROOT = STACK.ROOT = @scope
		scope.visit
		body.traverse

	def compile o
		STACK.reset # -- nested compilation does not work now
		OPTS = STACK.@options = @options = o or {}
		traverse

		@scope.options = STACK.@options

		var out = c
		var result = {
			js: out,
			ast: self,
			source: o.@source,
			warnings: scope.warnings,
			options: o,
			toString: (do this:js)
			styles: scope.styles,
			sfc: {id: @scope.sfcid}
		}


		

		var stylebody = ""
		for style in result:styles
			if style:type == 'css'
				let scoping = style:scoped ? result:sfc:id : null
				style:processed = csscompiler.compile(style:content,scope: scoping)
				stylebody += style:processed + '\n'

		# if stylebody and (o:inline-css or (!STACK.env('WEBPACK') && o:target == 'web'))
		if stylebody
			result:js = result:js.replace('{/*$sfc$*/}',JSON.stringify(result:sfc))
			result:js = "imba.inlineStyles({JSON.stringify(stylebody)});\n{result:js}"

		if o:sourceMapInline or o:sourceMap
			result:sourcemap = SourceMap.new(result).generate

		return result

	def js o
		var out
		unless @options:wrap
			out = scope.c
		else
			body.consume(ImplicitReturn.new)
			out = scope.c(indent: yes)
			out = out.replace(/^\n?/,'\n')
			out = out.replace(/\n?$/,'\n\n')
			out = '(function(){' + out + '})();'

		# find and replace shebangs
		var shebangs = []
		out = out.replace(/^[ \t]*\/\/(\!.+)$/mg) do |m,shebang|
			shebang = shebang.replace(/\bimba\b/g,'node')
			shebangs.push("#{shebang}\n")
			return ""

		out = shebangs.join('') + out

		return out


	def analyze o = {}
		# loglevel: 0, entities: no, scopes: yes
		STACK.loglevel = o:loglevel or 0
		STACK.@analyzing = true
		ROOT = STACK.ROOT = @scope
		OPTS = STACK.@options = {
			target: o:target
			loglevel: o:loglevel or 0
			analysis: {
				entities: (o:entities or no),
				scopes: (o:scopes ?= yes)
			}
		}

		traverse
		STACK.@analyzing = false

		return scope.dump

	def inspect
		true

export class ClassDeclaration < Code

	prop name
	prop superclass
	prop initor

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super

	def namepath
		@namepath ||= "{name ? name.c : '--'}"

	def metadata
		{
			type: 'class'
			namepath: namepath
			inherits: superclass?.namepath
			path: name and name.c.toString
			desc: @desc
			loc: loc
			symbols: @scope.entities
		}
		
	def loc
		if let d = option(:keyword)
			[d.@loc,body.loc[1]]
		else
			super

	def toJSON
		metadata

	def initialize name, superclass, body
		# what about the namespace?
		@traversed = no
		@name = name or LIT('')
		@superclass = superclass
		@scope = ClassScope.new(self)
		@body = AST.blk(body)
		@entities = {} # items should register the entities as they come
		self

	def visit
		# replace with some advanced lookup?
		@body.@delimiter = ''
		ROOT.entities.add(namepath,self)
		scope.visit
		body.traverse
		self

	def js o
		scope.virtualize # is this always needed?
		scope.context.value = name
		scope.context.reference = name

		# should probably also warn about stuff etc
		if option(:extension)
			@body.@delimiter = ','
			@body.set(braces: yes)
			return util.extend(name,body).c
			# return body.c

		var o = @options or {}
		var cname = name isa Access ? name.right : name
		# var namespaced = name != cname
		var initor = null
		var sup = superclass
		var mark = AST.mark(keyword)

		unless typeof cname == 'string'
			cname = cname.c

		var cpath = typeof name == 'string' ? name : name.c

		@cname = cname
		@cpath = cpath

		let jsbody = '{' + body.c() + '}'
		let jshead = "{keyword}"
		jshead += " {@cname}" if @cname
		jshead += " extends {sup.c}" if sup
		jshead = "export {jshead}" if option(:export)
		let js = "{jshead} {jsbody}"
		if option(:global)
			js = "{js}; {scope__.root.globalRef}.{@cname} = {@cname};"
		return js

export class TagDeclaration < Code

	prop name
	prop superclass
	prop initor

	def namepath
		"<{name}>"

	def toJSON
		{
			type: 'tag'
			namepath: namepath
			inherits: superclass ? "<{superclass.name}>" : null
			symbols: @scope.entities
			loc: loc
			desc: @desc
		}

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super
		
	def loc
		if let d = option(:keyword)
			[d.@loc,body.loc[1]]
		else
			super

	def initialize name, superclass, body
		@traversed = no
		@name = name
		@superclass = superclass
		@scope = TagScope.new(self)
		@body = AST.blk(body || [])
		@body.@delimiter = ''

	def visit
		if String(name).match(/^[A-Z]/)
			set(isClass: yes)

		ROOT.entities.register(self) # what if this is not local?


		@initor = MethodDeclaration.new([],[],Identifier.new('init$'),null,{})
		@inits = @initor.body

		

		# replace with some advanced lookup?
		let sfc = @scope.root.sfco
		scope.visit
		body.add(@initor)
		body.traverse
		@inits.add LIT("super.init$()") # if superclass

	def id
		name.id

	def js o
		scope.virtualize # is this always needed?
		scope.context.value = name
		scope.context.reference = name

		# should probably also warn about stuff etc
		let sup = CALL(LIT('imbaElements.get'),[superclass or LIT('')])

		if option(:extension)
			return body.c

		if @scope.root.styles:length > 0
			@inits.add LIT("this.setAttribute('data-{@scope.root.sfcid}','')")

		# var o = @options or {}
		# var cname = name isa Access ? name.right : name
		# var namespaced = name != cname
		# var initor = null
		# var sup = superclass
		var mark = AST.mark(keyword)

		# unless typeof cname == 'string'
		# 	cname = cname.c

		# var cpath = typeof name == 'string' ? name : name.c

		# @cname = cname
		# @cpath = cpath


		let closure = scope__.parent
		let clsvar = closure.reusevar('class$')
		let jsbody = '{' + body.c() + '}'
		let jshead = "{clsvar.c} = {mark}class extends {sup.c}"
		# jshead += " {@cname}" if @cname
		# jshead += " extends {sup.c}" if sup
		# jshead = "export {jshead}" if option(:export)
		let js = "{jshead} {jsbody}"
		js += "; imbaElements.define({name.c},{clsvar.c})"


		return js

	def js2 o
		scope.context.value = @ctx = scope.declare('tag',null,system: yes)

		# var ns = name.ns
		var mark = AST.mark(option('keyword'))
		var params = []

		params.push(name.c)
		var cbody = body.c

		if superclass
			# WARN what if the superclass has a namespace?
			# what if it is a regular class?
			let supname = superclass.name
			if !supname[0].match(/[A-Z]/)
				params.push(superclass.c)
				# supname = helpers.singlequote(supname)
			else
				params.push(supname)
		else
			params.push(LIT('null'))

		if body.count
			params.push("function({@ctx.c})\{{cbody}\}")
		else
			params.push(LIT('null'))

		params.push(@scope.root.sfco)

		var meth = option(:extension) ? 'extend' : 'define'
		# var js = "{mark}{scope__.imba.c}.{meth}({params.join(', ')})"
		var caller = LIT('imbaElements') #  scope__.imbaRef('tagscope')
		var js = "{mark}{caller}.{meth}({params.join(', ')})"

		if name.isClass
			let cname = name.name
			# declare variable
			js = "var {cname} = {js}"

			if option(:export)
				js = "{js}\nexports.{option(:default) ? 'default' : cname} = {cname};"

			if option(:return)
				js += "\nreturn {cname};"

		else
			if option(:return)
				js = "return " + js


		return js

		# return out

export class Func < Code

	prop name
	prop params
	prop target
	prop options
	prop type
	prop context

	def scopetype do FunctionScope

	def initialize params, body, name, target, o
		@options = o
		var typ = scopetype
		@traversed = no
		@body = AST.blk(body)
		@scope ||= (o and o:scope) || typ.new(self)
		@scope.params = @params = ParamList.new(params)
		@name = name || ''
		@target = target
		@type = :function
		@variable = null
		self

	def nonlocals
		@scope.@nonlocals

	def visit
		scope.visit
		@context = scope.parent
		@params.traverse
		@body.traverse # so soon?

	def funcKeyword
		let str = "function"
		str = "async {str}" if option(:async)
		return str

	def js o
		body.consume(ImplicitReturn.new) unless option(:noreturn)
		var ind = body.@indentation
		# var s = ind and ind.@open
		body.@indentation = null if ind and ind.isGenerated
		var code = scope.c(indent: (!ind or !ind.isGenerated), braces: yes)

		# args = params.map do |par| par.name
		# head = params.map do |par| par.c
		# code = [head,body.c(expression: no)].AST.flatten.compact.join("\n").wrap
		# FIXME creating the function-name this way is prone to create naming-collisions
		# will need to wrap the value in a FunctionName which takes care of looking up scope
		# and possibly dealing with it
		var name = typeof @name == 'string' ? @name : @name.c
		var name = name ? ' ' + name.replace(/\./g,'_') : ''
		var out = "{funcKeyword}{name}({params.c}) " + code
		# out = "async {out}" if option(:async)
		out = "({out})()" if option(:eval)
		return out

	def shouldParenthesize par = up
		par isa Call && par.callee == self
		# if up as a call? Only if we are


export class Lambda < Func
	def scopetype
		var k = option(:keyword)
		(k and k.@value == 'Æ’') ? (MethodScope) : (LambdaScope)


export class TagFragmentFunc < Func

	def scopetype
		# caching still needs to be local no matter what?
		option(:closed) ? (MethodScope) : (LambdaScope)

export class MethodDeclaration < Func

	prop variable

	def scopetype do MethodScope

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super

	def metadata
		{
			type: "method"
			name: "" + name
			namepath: namepath
			params: @params.metadata
			desc: @desc
			scopenr: scope.@nr
			loc: loc
		}

	def loc
		if let d = option(:def)
			let end = body.option(:end) or body.loc[1]
			[d.@loc,end]
		else
			[0,0]

	def isGetter
		@type == 'get'

	def isSetter
		@type == 'set'

	def isConstructor
		String(name) == 'constructor'

	def toJSON
		metadata

	def namepath
		return @namepath if @namepath

		var name = String(name.c)
		var sep = (option('static') ? '.' : '#')
		if target
			let ctx = target
			# console.log "target?? {@target.@parent} {@context.node}"
			if ctx.namepath == "ValueNode"
				ctx = @context.node

			@namepath = ctx.namepath + sep + name
		else
			@namepath = '&' + name

	def visit
		@type = option(:def)?.@value or 'def'

		@decorators = up?.collectDecorators
		var o = @options
		scope.visit

		var closure = @context = scope.parent.closure

		@params.traverse
		
		if option(:inObject)
			@body.traverse
			return self
			
		if target isa Identifier
			if let variable = scope.lookup(target.toString)
				target = variable
			# should be changed to VarOrAccess?!

		if String(name) == 'initialize' and (closure isa ClassScope) and !(closure isa TagScope) # and not ModuleScope?
			self.type = :constructor

		if String(name) == 'constructor' or isConstructor
			set(noreturn: yes)
		
		# instance-method / member
		if closure isa ClassScope and !target
			@target = closure.prototype
			set(prototype: @target,inClassBody: yes)
			closure.annotate(self)

		if target isa Self
			@target = closure.context
			closure.annotate(self)
			set(static: yes)
			
		elif o:variable
			@variable = scope.parent.register(name, self, type: String(o:variable))
			warn "{String(o:variable)} def cannot have a target" if target

		elif !target
			yes
		
		if o:export and !(closure isa RootScope)
			warn("cannot export non-root method", loc: o:export.loc)

		ROOT.entities.add(namepath,self)
		@body.traverse

		if isConstructor and option(:supr)
			let ref = scope__.context.@reference
			let supr = option(:supr)
			let node = supr:node
			let block = supr:block
			# console.log "isConstructor with super!"
			if ref
				ref.declarator.@defaults = null
				let op = OP('=',ref,This.new)
				# console.log "move before?! {block} {op.c}"
				block.replace node, [node,op]

		self

	def supername
		type == :constructor ? type : name


	# FIXME export global etc are NOT valid for methods inside any other scope than
	# the outermost scope (root)

	def js o
		var o = @options
		# FIXME Do this in the grammar - remnants of old implementation
		unless type == :constructor or option(:noreturn)
			if option(:chainable)
				body.add(ImplicitReturn.new(scope.context))
			elif option(:greedy)
				# haaack
				body.consume(GreedyReturn.new)
			else
				body.consume(ImplicitReturn.new)

		var code = scope.c(indent: yes, braces: yes)
		var name = typeof @name == 'string' ? @name : @name.c

		var out = ""
		var mark = AST.mark(option('def'))
		var fname = AST.sym(self.name)

		if option(:inClassBody) or option(:inObject)
			# what if this is async?
			let prefix = self.isGetter() ? 'get ' : (self.isSetter() ? 'set ' : '')
			prefix = "static {prefix}" if option(:static)
			prefix = "async {prefix}" if option(:async)
			out = "{prefix}{name}{mark}({params.c}){code}"
			return out

		var func = "({params.c})" + code
		var ctx = context

		if target
			if fname[0] == '['
				fname = fname.slice(1,-1)
			else
				fname = "'{fname}'"
			if isGetter
				out = "Object.defineProperty({target.c},'{fname}',\{get: {funcKeyword}{func}, configurable: true\})"
			elif isSetter
				out = "Object.defineProperty({target.c},'{fname}',\{set: {funcKeyword}{func}, configurable: true\})"
			else
				let k = OP('.',target,@name)
				out = "{mark}{k.c} = {funcKeyword} {func}"
			if o:export
				out = "exports.{o:default ? 'default' : fname} = {out}"
		else
			out = "{mark}{funcKeyword} {fname}{func}"
			if o:export
				out = "export {o:default ? 'default ' : ''}{out}"

		if o:global
			out = "{out}; {scope__.root.globalRef}.{fname} = {fname};"
		
		if option(:return)
			out = "return {out}"

		return out


export class TagFragmentDeclaration < MethodDeclaration


export class PropertyDeclaration < Node
	var propTemplate = '''

	get ${getter}(){ return ${get}; }
	set ${getter}(v){ ${set}; }
	${meta}
	'''

	var propWatchTemplate = '''
	get ${getter}(){ return ${get}; }
	set ${getter}(v){
		var a = ${get};
		if(v != a) { ${set}; }
		if(v != a) { ${ondirty} }
	}
	${meta}
	'''

	prop name
	prop options

	def initialize name, options, token
		@token = token
		@traversed = no
		@name = name
		@options = options || Obj.new(AssignList.new)

	def visit
		@options.traverse
		scope__.entities.add(name,self)
		self
	
	def toJSON
		{
			type: "prop"
			name: "" + name
			desc: @desc
			loc: loc
		}
	
	def loc
		[@token.@loc,@name.region[1]]

	# This will soon support bindings / listeners etc, much more
	# advanced generated code based on options passed in.
	def c
		var o = options
		var ast = ""
		var key = name.js
		var scope = STACK.scope

		var addDesc = o.keys:length

		var pars = o.hash

		var isAttr = (@token and String(@token) == 'attr')
		var isNative = pars:native isa Bool ? pars:native.isTruthy : undefined

		var js =
			key: key
			getter: key
			scope: "{scope.context.c}"
			path: '${scope}.prototype'
			set: "this.__{key} = v"
			get: "this.__{key}"
			init: ""
			headers: ""
			ondirty: ""

		var tpl = propTemplate

		o.add('name',Symbol.new(key))

		if pars:watch
			tpl = propWatchTemplate unless pars:watch isa Bool and !pars:watch.isTruthy
			var wfn = "{key}DidSet"

			if pars:watch isa Symbol
				wfn = pars:watch
			elif pars:watch isa Str
				wfn = pars:watch
			elif pars:watch isa Bool
				o.key(:watch).value = Symbol.new("{key}DidSet")
			else
				wfn = null

			if wfn
				let fn = OP('.',This.new,wfn)
				js:ondirty = OP('&&',fn,CALL(fn,['v','a',"this.__{key}"])).c
			else
				js:ondirty = "{scope__.imba.c}.propDidSet(this,this.__{key},v,a)"

		if isAttr # (@token and String(@token) == 'attr') or o.key(:dom) or o.key(:attr)
			js:set = 'this.setAttribute("${key}",v,${desc})'
			js:get = 'this.getAttribute("${key}",${desc})'

		elif o.key(:delegate)
			# if we have a delegate
			js:set = "v = this.__{key}.delegate.set('{key}',v,this,$\{desc\})"
			js:get = "this.__{key}.delegate.get('{key}',this,$\{desc\})"

		if pars:get isa Str
			js:get = "this.{pars:get.raw}()"

		if pars:set isa Str
			js:set = "this.{pars:set.raw}(v)"

		if pars:default
			# how can we support this with new syntax?
			js:init = "{js:path}._{key} = {pars:default.c};"

		js:options = o.c

		if addDesc
			let tmpvar = scope__.root.declare(null,o)
			js:desc = tmpvar.c
			js:meta = 'get ___${key}(){ return ${desc} }'

		var reg = /\$\{(\w+)\}/gm
		# var tpl = o.key(:watch) ? propWatchTemplate : propTemplate
		var out = tpl.replace(reg) do |m,a| js[a] or ''
		# run another time for nesting. hacky
		out = out.replace(reg) do |m,a| js[a] or ''
		# out = out.replace(/\n\s*$/,'')
		out = out.replace(/^\s+|\s+$/g, '')

		# if o.key(:v)
		return out



# Literals should probably not inherit from the same parent
# as arrays, tuples, objects would be better off inheriting
# from listnode.

export class Literal < ValueNode

	def initialize v
		@traversed = no
		@expression = yes
		@cache = null
		@raw = null
		@value = load(v)
		
	def load value
		value
		

	def toString
		"" + value

	def hasSideEffects
		false

	def shouldParenthesizeInTernary
		no


export class Bool < Literal

	# Should keep the real value (yes/no/true/false)?
	def initialize v
		@value = v
		@raw = String(v) == "true" ? true : false

	def cache
		self

	def isPrimitive
		yes

	def truthy
		String(value) == "true"
		# yes

	def js o
		String(@value)

	def c
		STACK.@counter += 1
		# undefined should not be a bool
		String(@value)
		# @raw ? "true" : "false"

	def toJSON
		{type: 'Bool', value: @value}

	def loc
		@value:region ? @value.region : [0,0]

export class Undefined < Literal

	def isPrimitive
		yes

	def isTruthy
		no

	def c
		AST.mark(@value) + "undefined"

export class Nil < Literal

	def isPrimitive
		yes

	def isTruthy
		no

	def c
		AST.mark(@value) + "null"

export class True < Bool

	def raw
		true

	def isTruthy
		yes

	def c
		AST.mark(@value) + "true"

export class False < Bool

	def raw
		false

	def isTruthy
		no

	def c
		AST.mark(@value) + "false"

export class Num < Literal

	# value is token - should not be
	def initialize v
		@traversed = no
		@value = v

	def toString
		String(@value)

	def isPrimitive deep
		yes

	def isTruthy
		String(@value) != "0"

	def shouldParenthesize par = up
		par isa Access and par.left == self

	def js o
		var num = String(@value)
		return num

	def c o
		return super(o) if @cache
		var js = String(@value)
		var par = STACK.current
		var paren = par isa Access and par.left == self
		# only if this is the right part of teh acces
		paren ? "({AST.mark(@value)}" + js + ")" : (AST.mark(@value) + js)
		# @cache ? super(o) : String(@value)

	def cache o
		return self unless o and (o:cache or o:pool)
		super(o)

	def raw
		# really?
		JSON.parse(String(value))

	def toJSON
		{type: typeName, value: raw}

# should be quoted no?
# what about strings in object-literals?
# we want to be able to see if the values are allowed
export class Str < Literal

	def initialize v
		@traversed = no
		@expression = yes
		@cache = null
		@value = v
		# should grab the actual value immediately?

	def isString
		yes

	def isPrimitive deep
		yes

	def raw
		# JSON.parse requires double-quoted strings,
		# while eval also allows single quotes.
		# NEXT eval is not accessible like this
		# WARNING TODO be careful! - should clean up

		@raw ||= String(value).slice(1,-1) # incredibly stupid solution

	def isValidIdentifier
		# there are also some values we cannot use
		raw.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false

	def js o
		String(@value)

	def c o
		@cache ? super(o) : String(@value)


export class Interpolation < ValueNode

# Currently not used - it would be better to use this
# for real interpolated strings though, than to break
# them up into their parts before parsing
export class InterpolatedString < Node

	def initialize nodes, o = {}
		@nodes = nodes
		@options = o
		self

	def add part
		@nodes.push(part) if part
		self

	def visit
		for node in @nodes
			node.traverse
		self
		
	def isString
		yes

	def escapeString str
		str = str.replace(/\n/g, '\\\n')

	def js o
		# creating the string
		var parts = []
		var str = @noparen ? '' : '('

		@nodes.map do |part,i|
			if part isa Token and part.@type == 'NEOSTRING'
				# esca
				parts.push('"' + escapeString(part.@value) + '"')
			elif part
				if i == 0
					# force first part to be string
					parts.push('""')
				part.@parens = yes
				parts.push(part.c(expression: yes))

		str += parts.join(" + ")
		str += ')' unless @noparen
		return str

# Because we've dropped the Str-wrapper it is kinda difficult
export class Symbol < Literal

	def isValidIdentifier
		raw.match(/^[a-zA-Z\$\_]+[\d\w\$\_]*$/) ? true : false

	def isPrimitive deep
		yes

	def raw
		@raw ||= AST.sym(value.toString.replace(/^\:/,''))

	def js o
		"'{AST.sym(raw)}'"

export class RegExp < Literal

	def isPrimitive
		yes

	def js
		var v = super
		
		# special casing heregex
		if var m = constants.HEREGEX.exec(v)
			# console.log 'matxhed heregex',m
			var re = m[1].replace(constants.HEREGEX_OMIT, '').replace(/\//g, '\\/')
			return '/' + (re or '(?:)') + '/' + m[2]
		
		v == '//' ? '/(?:)/' : v

# Should inherit from ListNode - would simplify
export class Arr < Literal

	def load value
		value isa Array ? ArgList.new(value) : value

	def push item
		value.push(item)
		self

	def count
		value:length

	def nodes
		var val = value
		val isa Array ? val : val.nodes

	def splat
		value.some(|v| v isa Splat)

	def visit
		@value.traverse if @value and @value:traverse
		self

	def isPrimitive deep
		!value.some(|v| !v.isPrimitive(yes) )

	def js o
		var val = @value
		return "[]" unless val
		var nodes = val isa Array ? val : val.nodes
		var out = val isa Array ? AST.cary(val) : val.c
		"[{out}]"

	def hasSideEffects
		value.some(|v| v.hasSideEffects )

	def toString
		"Arr"

	def indented a,b
		@value.indented(a,b)
		self

	def self.wrap val
		Arr.new(val)

# should not be cklassified as a literal?
export class Obj < Literal

	def load value
		value isa Array ? AssignList.new(value) : value

	def visit
		@value.traverse if @value
		# for v in value
		# 	v.traverse
		self

	def js o
		var dyn = value.filter(|v| v isa ObjAttr and (v.key isa Op or v.key isa InterpolatedString)  )

		if dyn:length > 0
			var idx = value.indexOf(dyn[0])
			# create a temp variable

			var tmp = scope__.temporary(self)
			# set the temporary object to the same
			var first = value.slice(0,idx)
			var obj = Obj.new(first)
			var ast = [OP('=',tmp,obj)]

			value.slice(idx).forEach do |atr|
				ast.push(OP('=',OP('.',tmp,atr.key),atr.value))
			ast.push(tmp) # access the tmp at in the last part
			return Parens.new(ast).c

		# for objects with expression-keys we need to think differently
		'{' + value.c + '}'

	def add k, v
		k = Identifier.new(k) if k isa String
		var kv = ObjAttr.new(k,v)
		value.push(kv)
		return kv

	def remove key
		for k in value
			value.remove(k) if k.key.symbol == key
		self

	def keys
		Object.keys(hash)

	def hash
		var hash = {}
		for k in value
			hash[k.key.symbol] = k.value if k isa ObjAttr
		return hash
		# return k if k.key.symbol == key

	# add method for finding properties etc?
	def key key
		for k in value
			return k if k isa ObjAttr and k.key.symbol == key
		null

	def indented a,b
		@value.indented(a,b)
		self

	def hasSideEffects
		value.some(|v| v.hasSideEffects )

	# for converting a real object into an ast-representation
	def self.wrap obj
		var attrs = []
		for own k,v of obj
			if v isa Array
				v = Arr.wrap(v)
			elif v:constructor == Object
				v = Obj.wrap(v)
			# if k isa String
			#	k = LIT(k)
			attrs.push(ObjAttr.new(k,v))
		return Obj.new(attrs)

	def toString
		"Obj"

export class ObjAttr < Node

	prop key
	prop value
	prop options

	def initialize key, value, defaults
		@traversed = no
		@key = key
		@value = value
		@dynamic = key isa Op
		@defaults = defaults
		self

	def visit
		# should probably traverse key as well, unless it is a dead simple identifier
		key.traverse
		value.traverse if value
		@defaults.traverse if @defaults

	def js o
		let key = self.key

		if key isa Identifier and String(key.@value)[0] == '@'
			key = Ivar.new(key)

		var k = key.isReserved ? "'{key.c}'" : key.c

		if @defaults
			"{k} = {@defaults.c}"
		elif value
			"{k}: {value.c}"
		else
			"{k}"

	def hasSideEffects
		true



export class ArgsReference < Node

	# should register in this scope --
	def c
		"arguments"

# should be a separate Context or something
export class Self < Literal

	def initialize value
		@value = value

	def cache
		self

	def reference
		return self

	def visit
		scope__.context
		self

	def c
		var s = scope__
		(s ? s.context.c : "this")

export class ImplicitSelf < Self

export class This < Self

	def cache
		self

	def reference
		self

	def visit
		self

	def c
		"this"




# OPERATORS

export class Op < Node

	prop op
	prop left
	prop right

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@opToken = o
		@op = o and o.@value or o
		
		if @op == 'and'
			@op = '&&'
		elif @op == 'or'
			@op = '||'
		elif @op == 'is'
			@op = '==='
		elif @op == 'isnt'
			@op = '!=='
		elif @op == 'not'
			@op = '!'
			
		@left = l
		@right = r
		return self

	def visit
		@right.traverse if @right
		@left.traverse if @left
		return self

	def isExpressable
		# what if right is a string?!?
		!right || right.isExpressable

	def js o
		var out = null
		var op = @op

		var l = @left
		var r = @right

		l = l.c if l isa Node
		r = r.c if r isa Node

		if l && r
			out = "{l} {AST.mark(@opToken)}{op} {r}"
		elif l
			out = "{AST.mark(@opToken)}{op}{l}"
		# out = out.parenthesize if up isa Op # really?
		out
		
	def isString
		@op == '+' and @left and @left.isString

	def shouldParenthesize
		@parens
		# option(:parens)

	def precedence
		10

	def consume node
		return super if isExpressable

		# TODO can rather use global caching?
		var tmpvar = scope__.declare(:tmp,null,system: yes)
		var clone = OP(op,left,null)
		var ast = right.consume(clone)
		ast.consume(node) if node
		return ast

export class ComparisonOp < Op

	def invert
		# are there other comparison ops?
		# what about a chain?
		var op = @op
		var pairs = [ "==","!=" , "===","!==" , ">","<=" , "<",">=" ]
		var idx = pairs.indexOf(op)
		idx += (idx % 2 ? -1 : 1)
		self.op = pairs[idx]
		@invert = !@invert
		self

	def c
		if left isa ComparisonOp
			left.right.cache
			OP('&&',left,OP(op,left.right,right)).c
		else
			super

	def js o
		var op = @op
		var l = @left
		var r = @right

		l = l.c if l isa Node
		r = r.c if r isa Node
		return "{l} {AST.mark(@opToken)}{op} {r}"


export class UnaryOp < Op

	def invert
		if op == '!'
			return left
		else
			super # regular invert

	def isTruthy
		var val = AST.truthy(left)
		return val !== undefined ? (!val) : (undefined)

	def js o
		var l = @left
		var r = @right
		var op = op

		if op == 'not'
			op = '!'

		if op == '!'
			# l.@parens = yes
			var str = l.c
			var paren = l.shouldParenthesize(self)
			# FIXME this is a very hacky workaround. Need to handle all this
			# in the child instead, problems arise due to automatic caching
			str = '(' + str + ')' unless str.match(/^\!?([\w\.]+)$/) or l isa Parens or paren or l isa Access or l isa Call
			# l.set(parens: yes) # sure?
			"{op}{str}"

		elif left
			"{l.c}{op}"

		else
			"{op}{r.c}"

	def normalize
		return self if op == '!'
		var node = (left || right).node
		# for property-accessors we need to rewrite the ast
		return self unless node isa PropertyAccess

		# ask to cache the path
		node.left.cache if node isa Access && node.left

		var num = Num.new(1)
		var ast = OP('=',node,OP(op[0],node,num))
		ast = OP(op[0] == '-' ? '+' : '-',ast,num) if left

		return ast

	def consume node
		var norm = normalize
		norm == self ? super : norm.consume(node)

	def c
		var norm = normalize
		norm == self ? super : norm.c

export class InstanceOf < Op

	def js o
		# fix checks for String and Number

		if right isa Const
			# WARN otherwise - what do we do? does not work with dynamic
			# classes etc? Should probably send to utility function isa$
			var name = AST.c(right.value)
			var obj = left.node
			# TODO also check for primitive-constructor
			if name in ['String','Number','Boolean']
				unless obj isa LocalVarAccess
					obj.cache
				# need a double check for these (cache left) - possibly
				return "(typeof {obj.c}=='{name.toLowerCase}'||{obj.c} instanceof {name})"

				# convert
		var out = "{left.c} instanceof {right.c}"

		# should this not happen in #c?
		out = helpers.parenthesize(out) if o.parent isa Op
		out

export class TypeOf < Op

	def js o
		"typeof {left.c}"

export class Delete < Op

	def js o
		# TODO this will execute calls several times if the path is not directly to an object
		# need to cache the receiver
		var l = left
		var tmp = scope__.temporary(self, pool: 'val')
		var o = OP('=',tmp,l)
		# FIXME
		return "({o.c},delete {l.c}, {tmp.c})" # oh well
		# var ast = [OP('=',tmp,left),"delete {left.c}",tmp]
		# should parenthesize directly no?
		# ast.c

	def shouldParenthesize
		yes

export class In < Op

	def invert
		@invert = !@invert
		self

	def js o
		var cond = @invert ? "== -1" : ">= 0"
		var idx = Util.indexOf(left,right)
		"{idx.c} {cond}"



# ACCESS

export class Access < Op

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@op = o and o.@value or o
		@left = l
		@right = r
		return self

	def clone left, right
		var ctor = self:constructor
		ctor.new(op,left,right)

	def js o
		var raw = null
		var rgt = right
		var ctx = (left || scope__.context)
		var pre = ""
		var mark = ''

		# if safechain
		#	p "Access is safechained {rgt.c}"


		if rgt isa Num
			return ctx.c + "[" + rgt.c + "]"

		# is this right? Should not the index compile the brackets
		# or value is a symbol -- should be the same, no?
		if rgt isa Index and (rgt.value isa Str or rgt.value isa Symbol)
			rgt = rgt.value

		# TODO do the identifier-validation in a central place instead
		if rgt isa Str and rgt.isValidIdentifier
			raw = rgt.raw

		elif rgt isa Symbol and rgt.isValidIdentifier
			raw = rgt.raw

		elif rgt isa Identifier and rgt.isValidIdentifier
			mark = AST.mark(rgt.@value)
			raw = rgt.c

		if safechain and ctx
			ctx.cache(force: yes)
			pre = ctx.c + " && "

		# really?
		# var ctx = (left || scope__.context)
		var out = if raw
			# see if it needs quoting
			# need to check to see if it is legal
			ctx ? "{ctx.c}.{mark}{raw}" : raw
		else
			var r = rgt isa Node ? rgt.c(expression: yes) : rgt
			"{ctx.c}[{r}]"

		# if safechain and ctx
		# 	out = "{ctx.c} && {out}"

		return pre + out

	def visit
		left.traverse if left
		right.traverse if right
		return

	def isExpressable
		true

	def alias
		right isa Identifier ? right.alias : super()

	def safechain
		# right.safechain
		String(@op) == '?.' or String(@op) == '?:'

	def cache o
		(right isa Ivar && !left) ? self : super(o)

	def shouldParenthesizeInTernary
		@parens or @cache


# Should change this to just refer directly to the variable? Or VarReference
export class LocalVarAccess < Access

	prop safechain

	def js o
		if right isa Variable and right.type == 'meth'
			return "{right.c}()" unless up isa Call

		right.c

	def variable
		right

	def cache o = {}
		super(o) if o:force
		self

	def alias
		variable.@alias or super()


export class GlobalVarAccess < ValueNode

	def js o
		value.c


export class ObjectAccess < Access


export class PropertyAccess < Access

	def initialize o, l, r
		@traversed = no
		@invert = no
		@parens = no
		@expression = no # yes?
		@cache = null
		@op = o
		@left = l
		@right = r
		return self

	def visit
		@right.traverse if @right
		@left.traverse if @left
		return self

	# right in c we should possibly override
	# to create a call and regular access instead

	def js o
		if var rec = receiver
			var ast = CALL(OP('.',left,right),[]) # convert to ArgList or null
			ast.receiver = rec
			return ast.c

		var up = up
		# really need to fix this - for sure
		# should be possible for the function to remove this this instead?
		var js = "{super(o)}"
		return js


	def receiver
		if left isa SuperAccess || left isa Super
			SELF
		else
			null


export class IvarAccess < Access

	def visit
		@right.traverse if @right
		@left ? @left.traverse : scope__.context
		return self

	def cache
		# WARN hmm, this is not right... when accessing on another object it will need to be cached
		return self


export class ConstAccess < Access


export class IndexAccess < Access

	def cache o = {}
		return super if o:force
		right.cache
		self


export class SuperAccess < Access

	def js o
		var m = o.method
		var up = o.parent
		var deep = o.parent isa Access

		var out = "{left.c}.__super__"

		unless up isa Access
			out += ".{m.supername.c}"
			unless up isa Call
				out += ".apply({m.scope.context.c},arguments)"

		return out

	def receiver
		SELF


export class VarOrAccess < ValueNode

	def initialize value
		# should rather call up to valuenode?
		@traversed 	= no
		@parens 	= no
		@value 		= value
		@identifier = value
		@token 		= value.@value
		@variable = null
		self

	# Shortcircuit traverse so that it is not added to the stack?!
	def visit
		# @identifier = value # this is not a real identifier?
		# console.log "VarOrAccess {@identifier}"

		var scope = scope__

		var variable = scope.lookup(value)

		# does not really need to have a declarator already? -- tricky
		if variable && variable.declarator
			# var decl = variable.declarator
			let vscope = variable.scope

			# if the variable is not initialized just yet and we are
			# in the same scope - we should not treat this as a var-lookup
			# ie.  var x = x would resolve to var x = this.x() if x
			# was not previously defined
			if vscope == scope and !variable.@initialized
				# here we need to check if the variable exists outside
				# if it does - we need to ensure that the inner variable does not collide
				let outerVar = scope.parent.lookup(value)
				if outerVar
					variable.@virtual = yes
					variable.@shadowing = outerVar
					variable = outerVar

			# should do this even if we are not in the same scope?
			# we only need to be in the same closure(!)

			if variable and variable.@initialized or (scope.closure != vscope.closure)
				@variable = variable
				variable.addReference(self)
				@value = variable # variable.accessor(self)
				@token.@variable = variable
				
				# if vscope isa RootScope and vscope.context != scope.context and variable.type == 'meth'
				# 	warn "calling method from root scope {value} is deprecated - see issue #112"

				return self

			# FIX
			# @value.safechain = safechain

		# TODO deprecate and remove
		if value.symbol.indexOf('$') >= 0 or true
			# big hack - should disable
			# major hack here, no?
			# console.log "GlobalVarAccess"
			@value = GlobalVarAccess.new(value)
			return self

		# really? what about just mimicking the two diffrent instead?
		# Should we not return a call directly instead?
		scope.root.@implicitAccessors.push(self)
		@value = PropertyAccess.new(".",scope.context,value)
		# mark the scope / context -- so we can show correct implicit
		@token.@meta = {type: 'ACCESS'}
		# @value.traverse # nah
		self

	def c
		AST.mark(@token) + (@variable ? super() : value.c)

	def js o

		if var v = @variable
			var out = v.c
			out += "()" if v.@type == 'meth' and !(o.up isa Call)
			return out
		return "NONO"

	def node
		@variable ? self : value

	def symbol
		@identifier.symbol
		# value and value.symbol

	def cache o = {}
		@variable ? (o:force and super(o)) : value.cache(o)

	def decache
		@variable ? super() : value.decache
		self

	def dom
		value.dom

	def safechain
		@identifier.safechain

	def dump
		{ loc: loc }

	def loc
		var loc = @identifier.region
		return loc or [0,0]

	def region
		@identifier.region

	def shouldParenthesizeInTernary
		@cache or (@value and @value.@cache) or @parens

	def toString
		"VarOrAccess({value})"

	def toJSON
		{type: typeName, value: @identifier.toString}

#	def js
#		if right isa Variable and right.type == 'meth'
#			return "{right.c}()" unless up isa Call
#
#		right.c
#
#	def variable
#		right
#
#	def cache o = {}
#		super if o:force
#		self
#
#	def alias
#		variable.@alias or super # if resolved?
#

export class VarReference < ValueNode

	# TODO VarBlock should convert these to plain / dumb nodes

	prop variable
	prop declared
	prop type

	def initialize value, type
		if value isa VarOrAccess
			value = value.value
			@variable = null
		elif value isa Variable
			@variable = value
			value = ""

		# for now - this can happen
		super(value)
		@export = no
		@type = type and String(type)
		@declared = yes # just testing now


	def loc
		@value.region

	# def set o
	# 	# hack - workaround for hidden classes perf
	# 	@export = yes if o:export
	# 	return self

	def js o
		# experimental fix

		# what about resolving?
		var ref = @variable
		if value isa Obj or value isa Arr
			ref = value

		var out = "{AST.mark(@value)}{ref.c}"
		var keyword = o.es5 ? 'var' : (@type or 'var')

		if ref && !ref.@declared # .option(:declared)
			if o.up(VarBlock) # or o.up(VarDeclList) # up varblock??
				ref.@declared = yes

				# ref.set(declared: yes)
			elif o.isExpression or @export
				# console.log "autodeclare {@value}"
				ref.autodeclare
			else
				out = "{keyword} {out}"
				ref.@declared = yes
				# ref.set(declared: yes)

		# need to think the export through -- like registering somehow
		# should register in scope - export on analysis++
		if option(:decl) and option(:decl).option(:export)
			out = "export {out}"

		# if @export
		# 	out = "module.exports.{ref.c} = {ref.c}"

		return out

	def declare
		self

	def consume node
		# really? the consumed node dissappear?
		@variable && @variable.autodeclare
		self

	def visit
		# should be possible to have a VarReference without a name as well? for a system-variable
		# name should not set this way.
		var v = @variable ||= scope__.register(value.toString, self, type: @type)

		# FIXME -- should not simply override the declarator here(!)
		if !v.declarator
			v.declarator = self

		v.addReference(@value) if @value # is this the first reference?

		# only needed when analyzing?
		@value.@value.@variable = v
		self

	def refnr
		variable.references.indexOf(value)

	# convert this into a list of references
	def addExpression expr
		VarBlock.new([self]).addExpression(expr)


# ASSIGN

export class Assign < Op

	def initialize o, l, r
		# set expression yes, no?
		@expression = no
		@traversed = no
		@parens = no
		@cache = null
		@invert = no
		@opToken = o
		@op = o and o.@value or o
		@left = l
		@right = r
		return self

	def isExpressable
		!right || right.isExpressable

	def isUsed
		# really?
		# if up is a block in general this should not be used -- since it should already have received implicit self?
		if up isa Block # && up.last != self
			return no
		return yes

	# FIXME optimize
	def visit
		var l = @left
		var r = @right

		# WARNING - slightly undefined
		# MARK THE STACK
		l.traverse if l

		var lvar = l isa VarReference and l.variable

		# how does this work with constants that are really var references?
		# should work when things are not described as well - but this is for testing
		# but if it refers to something else
		if !lvar and @desc
			# entities should be able to extract the needed info instead
			ROOT.entities.add(l.namepath,{namepath: l.namepath, type: r.typeName, desc: @desc})

		# this should probably be done in a different manner
		if lvar and lvar.declarator == l
			lvar.@initialized = no
			r.traverse if r
			lvar.@initialized = yes

		else
			r.traverse if r

		if l isa VarReference or l.@variable
			l.@variable.assigned(r,self)

		return self

	def c o
		unless right.isExpressable
			if left isa VarReference and left.type == 'let'
				return Block.new([left,BR,right.consume(self)]).c(o)
			return right.consume(self).c(o)
		# testing this
		return super(o)

	def js o
		unless right.isExpressable
			p "Assign#js right is not expressable "
			# here this should be go out of the stack(!)
			# it should already be consumed?
			return right.consume(self).c
		var l = left.node
		var r = right

		# We are setting self(!)
		# TODO document functionality
		if l isa Self
			var ctx = scope__.context
			l = ctx.reference

		var lc = l.c
		var out = "{lc} {AST.mark(@opToken)}{op} {right.c(expression: true)}"

		if l isa Obj
			out = "({out})"

		return out

	# FIXME op is a token? _FIX_
	# this (and similar cases) is broken when called from
	# another position in the stack, since 'up' is dynamic
	# should maybe freeze up?
	def shouldParenthesize par = up
		@parens or par isa Op && par.op != '='

	def consume node
		if isExpressable
			forceExpression
			return super(node)

		var ast = right.consume(self)
		return ast.consume(node)

	# more workaround during transition away from a,b,c = 1,2,3 style assign
	def addExpression expr
		# p "addExpression {expr}"
		var typ = ExpressionBlock
		if @left and @left isa VarReference
			typ = VarBlock
		# might be better to nest this up after parsing is done?
		var node = typ.new([self])
		return node.addExpression(expr)


export class PushAssign < Assign
	
	prop consumed
	
	def register node
		@consumed ||= []
		@consumed.push(node)
		self
		
	def js o
		"{left.c}.push({right.c})"

	def consume node
		return self

export class TagPushAssign < PushAssign

	def js o
		"{left.c}.push({right.c})"

	def consume node
		return self


export class ConditionalAssign < Assign

	def consume node
		normalize.consume(node)

	def normalize
		var l = left.node
		var ls = l

		if l isa Access
			if l.left
				l.left.cache
			ls = l.clone(l.left,l.right) # this should still be cached?
			l.cache if l isa PropertyAccess # correct now, to a certain degree
			if l isa IndexAccess
				l.right.cache

			# we should only cache the value itself if it is dynamic?
			# l.cache # cache the value as well -- we cannot use this in assigns them

		# some ops are less messy
		# need op to support consume then?
		var expr = right.isExpressable
		var ast = null
		# here we should use ast = if ...
		if expr && op == '||='
			ast = OP('||',l, OP('=',ls,right))
		elif expr && op == '&&='
			ast = OP('&&',l, OP('=',ls,right))
		else
			ast = IF(condition, OP('=',ls,right), l) # do we need a scope for these?
			ast.scope = null
			# drop the scope
			# touch scope -- should probably visit the whole thing?
			# ast.scope.visit
		ast.toExpression if ast.isExpressable
		ast


	def c
		# WARN what if we return the same?
		normalize.c

	def condition

		# use switch instead to cache op access
		if op == '?='
			OP('==',left,NULL)
		elif op == '||='
			OP('!',left)
		elif op == '&&='
			left
		elif op == '!?='
			OP('!=',left,NULL)
		else
			left

	def js o
		var ast = IF(condition, OP('=',left,right), left)
		ast.scope = null # not sure about this
		ast.toExpression if ast.isExpressable # forced expression already
		return ast.c

export class CompoundAssign < Assign

	# FIXME can we merge consume and js?
	def consume node
		return super if isExpressable

		var ast = normalize
		return ast.consume(node) unless ast == self

		ast = right.consume(self)
		return ast.consume(node)

	def normalize
		var ln = left.node
		# we dont need to change this at all
		unless ln isa PropertyAccess
			return self

		if ln isa Access
			# left might be zero?!?!
			ln.left.cache if ln.left
		# TODO FIXME we want to cache the context of the assignment
		var ast = OP('=',left,OP(op[0],left,right))
		ast.toExpression if ast.isExpressable

		return ast

	def c
		var ast = normalize
		return super if ast == self

		# otherwise it is important that we actually replace this node in the outer block
		# whenever we normalize and override c it is important that we can pass on caching
		# etc -- otherwise there WILL be issues.
		var up = STACK.current
		if up isa Block
			# an alternative would be to just pass
			up.replace(self,ast)
		ast.c


# IDENTIFIERS

# really need to clean this up
# Drop the token?
export class Identifier < Node

	prop safechain
	prop value

	def initialize value
		@value = load(value)
		@symbol = null
		@setter = null

		if ("" + value).indexOf("?") >= 0
			@safechain = yes
		# @safechain = ("" + value).indexOf("?") >= 0
		self

	def references variable
		@value.@variable = variable if @value
		self

	def sourceMapMarker
		@value.sourceMapMarker

	def load v
		return (v isa Identifier ? v.value : v)

	def traverse
		# NODES.push(self)
		self

	def visit

		if @value isa Node
			# console.log "IDENTIFIER VALUE IS NODE"
			@value.traverse
		self

	def region
		[@value.@loc,@value.@loc + @value.@len]

	def isValidIdentifier
		yes

	def isReserved
		@value:reserved or RESERVED_TEST.test(String(@value))

	def symbol
		# console.log "Identifier#symbol {value}"
		@symbol ||= AST.sym(value)

	def setter
		# console.log "Identifier#setter"
		@setter ||= if true
			var tok = Token.new('IDENTIFIER',AST.sym('set-' + @value),@value.@loc or -1)
			Identifier.new(tok)
			# Identifier.new("set-{symbol}")

	def toString
		String(@value)

	def toJSON
		toString

	def alias
		AST.sym(@value)

	def js o
		symbol

	def c
		return '' + symbol # AST.mark(@value) +

	def dump
		{ loc: region }

	def namepath
		toString

	def shouldParenthesizeInTernary
		@parens or @cache

export class TagIdRef < Identifier

	def initialize v
		@value = v isa Identifier ? v.value : v
		self

	def c
		"{scope__.imba.c}.getTagSingleton('{value.c.substr(1)}')"


# This is not an identifier - it is really a string
# Is this not a literal?

# FIXME Rename to IvarLiteral? or simply Literal with type Ivar
export class Ivar < Identifier
	
	var prefix = '_' # '_'

	def initialize v
		@value = v isa Identifier ? v.value : v
		@private = String(@value)[0] == '#'
		self

	def isPrivate
		!!@private

	def name
		(@private ? '__' : '') + helpers.dashToCamelCase(@value).replace(/^[@\#]/,'')
		# value.c.camelCase.replace(/^@/,'')

	def prefixed
		name # (@private ? '__' : '') + name

	def alias
		prefixed

	# the @ should possibly be gone from the start?
	def js o
		return prefixed

	def c
		return prefixed

export class Decorator < ValueNode
	
	def visit
		@call.traverse if @call

		if let block = up
			block.@decorators ||= []
			block.@decorators.push(self)

# Ambiguous - We need to be consistent about Const vs ConstAccess
# Becomes more important when we implement typeinference and code-analysis
export class Const < Identifier

	def symbol
		# console.log "Identifier#symbol {value}"
		@symbol ||= AST.sym(value)

	def js o
		@variable ? @variable.c : symbol

	def traverse
		if @traversed
			return

		@traversed = true
		var curr = STACK.current
		if !(curr isa Access) or curr.left == self
			if symbol == "Imba"
				@variable = scope__.imba
			else
				@variable = scope__.lookup(value)
		self

	def c
		if option(:export)
			"exports.{@value} = " + AST.mark(@value) + js
		else
			AST.mark(@value) + js


export class TagTypeIdentifier < Identifier

	prop name
	prop ns

	def initialize value
		@token = value
		@value = load(value)
		self

	def load val
		@str = ("" + val)
		var parts = @str.split(":")
		@raw = val
		@name = parts.pop
		@ns = parts.shift # if any?
		return @str

	def js o
		return "'" + @str + "'"

	def c
		js

	def func
		var name = @name.replace(/-/g,'_').replace(/\#/,'')
		name += "${@ns.toLowerCase}" if @ns
		name

	def isClass
		!!@str.match(/^[A-Z]/)
		# @name[0] == @name[0].toUpperCase and 
		
	def isNative
		!@ns and TAG_TYPES.HTML.indexOf(@str) >= 0
	
	def isSimpleNative
		isNative and !(/input|textarea|select|form|iframe/).test(@str)

	def toFunctionalType
		LIT(@str)

	def spawner
		console.log "TagTypeIdentifier shuold never be used"
		if @ns
			"_{@ns.toUpperCase}.{@name.replace(/-/g,'_').toUpperCase}"
		else
			"{@name.replace(/-/g,'_').toUpperCase}"

	def id
		var m = @str.match(/\#([\w\-\d\_]+)\b/)
		m ? m[1] : null


	def flag
		"_" + name.replace(/--/g,'_').toLowerCase

	def sel
		".{flag}" # + name.replace(/-/g,'_').toLowerCase

	def string
		value

	def toString
		value

export class InterpolatedIdentifier < ValueNode
	def js
		"[{value.c}]"

export class Argvar < ValueNode

	def c
		# NEXT -- global.parseInt or Number.parseInt (better)
		var v = parseInt(String(value))
		# FIXME Not needed anymore? I think the lexer handles this
		return "arguments" if v == 0

		var s = scope__
		# params need to go up to the closeste method-scope
		var par = s.params.at(v - 1,yes)
		"{AST.c(par.name)}" # c


# CALL

export class Call < Node

	prop callee
	prop receiver
	prop args
	prop block

	def initialize callee, args, opexists
		@traversed = no
		@expression = no
		@parens = no
		@cache = null
		@receiver = null
		@opexists = opexists
		# some axioms that share the same syntax as calls will be redirected from here

		if callee isa VarOrAccess
			var str = callee.value.symbol
			if str == 'extern'
				callee.value.value.@type = 'EXTERN'
				return ExternDeclaration.new(args)
			if str == 'tag'
				# console.log "ERROR - access args by some method"
				return TagWrapper.new(args and args:index ? args.index(0) : args[0])
			if str == 'export'
				return Export.new(args)


		@callee = callee	
		@args = args or ArgList.new([])

		if args isa Array
			@args = ArgList.new(args)
			
		if callee isa Decorator
			callee.@call = self
			return callee

		return self
		
	def loc
		@callee.loc

	def visit
		args.traverse
		callee.traverse
		# if the callee is a PropertyAccess - better to immediately change it

		@block && @block.traverse

	def addBlock block
		var pos = @args.filter(|n,i| n == '&')[0] # WOULD BE TOKEN - CAREFUL
		pos ? args.replace(pos,block) : args.push(block)
		self

	def receiver
		@receiver ||= (callee isa Access && callee.left || NULL)

	# check if all arguments are expressions - otherwise we have an issue

	def safechain
		callee.safechain # really?

	def shouldParenthesizeInTernary
		@parens or safechain or @cache

	def js o
		var opt = expression: yes
		var rec = null
		# var args = AST.compact(args) # really?
		var args = args

		# drop this?

		var splat = args.some do |v| v isa Splat

		var out = null
		var lft = null
		var rgt = null
		var wrap = null

		var callee = @callee = @callee.node # drop the var or access?

		# if callee isa Call && callee.safechain
		#	yes

		if callee isa Access
			lft = callee.left
			rgt = callee.right

		if callee isa Super or callee isa SuperAccess
			# @receiver = scope__.context
			self
			# return "supercall"

		# never call the property-access directly?
		if callee isa PropertyAccess # && rec = callee.receiver
			@receiver = callee.receiver
			callee = @callee = Access.new(callee.op,callee.left,callee.right)
			# console.log "unwrapping the propertyAccess"

		if rgt isa Identifier and rgt.value == 'len' and args.count == 0
			return Util.Len.new([lft or callee]).c

		elif rgt isa Identifier and rgt.value == 'assert' and !splat
			let arg = args.first
			# if arg isa Op
			arg.option(:assertion,yes)
			args.@nodes[0] = AssertionNode.new(arg)
			# console.log "Special assert call!! {arg.c}",arg isa Op

			# rewrite a.len(..) to len$(a)

		if callee.safechain
			# Does this affect shouldParenthesizeInTernary?
			# if lft isa Call
			# if lft isa Call # could be a property access as well - it is the same?
			# if it is a local var access we simply check if it is a function, then call
			# but it should be safechained outside as well?
			# lft.cache if lft
			# the outer safechain should not cache the whole call - only ask to cache
			# the result? -- chain onto
			var isfn = Util.IsFunction.new([callee])
			wrap = ["{isfn.c}  &&  ",""]
			callee = OP('.',callee.left,callee.right)
			# callee should already be cached now -

		# should just force expression from the start, no?
		if splat
			# important to wrap the single value in a value, to keep implicit call
			# this is due to the way we check for an outer Call without checking if
			# we are the receiver (in PropertyAccess). Should rather wrap in CallArguments
			let rec = receiver
			var ary = (args.count == 1 ? ValueNode.new(args.first.value) : Arr.new(args.list))

			rec.cache # need to cache the context as it will be referenced in apply
			out = "{callee.c(expression: yes)}.apply({rec.c},{ary.c(expression: yes)})"

		elif @receiver
			# quick workaround
			@receiver.cache unless @receiver isa ScopeContext
			args.unshift(receiver)
			# should rather rewrite to a new call?
			out = "{callee.c(expression: yes)}.call({args.c(expression: yes)})"

		else
			out = "{callee.c(expression: yes)}({args.c(expression: yes)})"

		if wrap
			# we set the cachevar inside
			if @cache
				@cache:manual = yes
				out = "({cachevar.c}={out})"

			out = [wrap[0],out,wrap[1]].join("")

		return out




export class ImplicitCall < Call

	def js o
		"{callee.c}()"

export class New < Call

	def js o
		var target = callee

		while target isa Access
			let left = target.left

			if (left isa PropertyAccess) or (left isa VarOrAccess)
				callee.@parens = yes
				break

			target = left

		var out = "new {callee.c}"
		out += '()' unless o.parent isa Call
		out

export class SuperCall < Call

	def js o
		var m = o.method
		self.receiver = SELF
		self.callee = "{m.target.c}.super$.prototype.{m.name.c}"
		super



export class ExternDeclaration < ListNode

	def visit
		nodes = map do |item| item.node # drop var or access really
		# only in global scope?
		var root = scope__
		for item in nodes
			var variable = root.register item.symbol, item, type: 'global'
			variable.addReference(item)
		self

	def c
		"// externs"


# FLOW

export class ControlFlow < Node

	def loc
		@body ? @body.loc : [0,0]

export class ControlFlowStatement < ControlFlow

	def isExpressable
		no


export class If < ControlFlow

	prop test
	prop body
	prop alt
	prop scope
	prop prevIf

	def self.ternary cond, body, alt
		# prefer to compile it this way as well
		var obj = If.new(cond, Block.new([body]), type: '?')
		obj.addElse Block.new([alt])
		return obj

	def addElse add
		if alt && alt isa If
			alt.addElse(add)
		else
			self.alt = add
			if add isa If
				add.prevIf = self
		self

	def initialize cond, body, o = {}
		setup
		@test = cond # (o:type == 'unless' ? UnaryOp.new('!',cond,null) : cond)
		@body = body
		@alt  = null
		@type = o:type
		invert if @type == 'unless'
		@scope = IfScope.new(self)
		self

	def loc
		@loc ||= [@type ? @type.@loc : 0,body.loc[1]]

	def invert
		if @test isa ComparisonOp
			@test = @test.invert
		else
			@test = UnaryOp.new('!',@test,null)

	def visit stack
		var alt = alt

		@scope.visit if @scope
		test.traverse if test
		
		@tag = stack.@tag
		
		if @tag
			@tag.set(hasConditionals: yes)

		# console.log "vars in if",Object.keys(@scope.varmap)
		for own name, variable of @scope.varmap
			if variable.type == 'let'
				variable.@virtual = yes

		# the let-variables declared in if(*test*) should be
		# local to the inner scope, but will technically be
		# declared in the outer scope. Must get unique name

		unless stack.isAnalyzing
			@pretest = AST.truthy(test)

			if @pretest === true
				alt = @alt = null

			elif @pretest === false
				loc # cache location before removing body
				body = null

		body.traverse if body

		# should skip the scope in alt.
		if alt
			STACK.pop(self)
			alt.@scope ||= BlockScope.new(alt)
			alt.traverse
			STACK.push(self)

		# force it as expression?
		toExpression if @type == '?' and isExpressable
		self


	def js o
		var body = body
		# would possibly want to look up / out
		var brace = braces: yes, indent: yes

		if @pretest === true and false
			# what if it is inside expression?
			let js = body ? body.c(braces: !!prevIf) : 'true'

			unless prevIf
				js = helpers.normalizeIndentation(js)

			if o.isExpression
				js = '(' + js + ')'

			return js

		elif @pretest === false and false
			alt.prevIf = prevIf if alt isa If
			let js = alt ? alt.c(braces: !!prevIf) : ''

			unless prevIf
				js = helpers.normalizeIndentation(js)

			return js
		

		if o.isExpression

			if test?.shouldParenthesizeInTernary
				test.@parens = yes

			var cond = test.c(expression: yes) # the condition is always an expression

			var code = body ? body.c : 'true' # (braces: yes)

			if body and body.shouldParenthesizeInTernary
				code = '(' + code + ')' # if code.indexOf(',') >= 0

			if alt
				var altbody = alt.c
				if alt.shouldParenthesizeInTernary
					altbody = '(' + altbody + ')'

				return "{cond} ? {code} : {altbody}"
			else
				# again - we need a better way to decide what needs parens
				# maybe better if we rewrite this to an OP('&&'), and put
				# the parens logic there
				# cond should possibly have parens - but where do we decide?
				if @tag
					return "{cond} ? {code} : void(0)"
				else
					return "{cond} && {code}"
		else
			# if there is only a single item - and it is an expression?
			var code = null
			var cond = test.c(expression: yes) # the condition is always an expression

			# if body.count == 1 # dont indent by ourselves?

			if body isa Block and body.count == 1 and !(body.first isa LoopFlowStatement)
				body = body.first

			# if body.count == 1
			#	p "one item only!"
			#	body = body.first

			code = body ? body.c(braces: yes) : '{}' # (braces: yes)

			# don't wrap if it is only a single expression?
			var out = "{AST.mark(@type)}if ({cond}) " + code # ' {' + code + '}' # '{' + code + '}'
			out += " else {alt.c(alt isa If ? {} : brace)}" if alt
			out

	def sourceMapMarker
		self

	def shouldParenthesize
		!!@parens

	def consume node
		if node isa TagLike
			# now we are reconsuming this
			if node.body == self
				@body = @body.consume(node) if @body
				@alt = @alt.consume(node) if @alt
				return self
			else
				return node.register(self)
			return self

		if node isa TagPushAssign or node isa TagFragment
			node.register(self)
			@body = @body.consume(node) if @body
			@alt = @alt.consume(node) if @alt
			return self

		# special case for If created from conditional assign as well?
		# @type == '?' and
		# ideally we dont really want to make any expression like this by default
		var isRet = node isa Return

		# might have been forced to expression already
		# if it was originally a ternary - why not
		if @expression or ((!isRet or @type == '?') and isExpressable)
			toExpression # mark as expression(!) - is this needed?
			return super(node)
		else
			@body = @body.consume(node) if @body
			@alt = @alt.consume(node) if @alt
		self


	def isExpressable
		# process:stdout.write 'x'
		var exp = (!body || body.isExpressable) && (!alt || alt.isExpressable)
		return exp



export class Loop < Statement


	prop scope
	prop options
	prop body
	prop catcher

	def loc
		var a = @options:keyword
		var b = @body

		if a and b
			# FIXME does not support POST_ variants yet
			[a.@loc,b.loc[1]]
		else
			[0,0]

	def initialize options = {}
		@traversed = no
		@options = options
		@body = null
		self

	def set obj
		@options ||= {}
		var keys = Object.keys(obj)
		for k in keys
			@options[k] = obj[k]
		self


	def addBody body
		self.body = AST.blk(body)
		self

	def isReactive
		@tag and @tag.fragment.isReactive

	def c o

		var s = stack
		var curr = s.current

		if stack.isExpression or isExpression
			# what the inner one should not be an expression though?
			# this will resut in an infinite loop, no?!?
			scope.closeScope
			var ast = CALL(FN([],[self]),[])
			return ast.c o

		elif stack.current isa Block or (s.up isa Block and s.current.@consumer == self)
			super.c o
		elif @tag
			super.c 0
		else
			scope.closeScope
			var ast = CALL(FN([],[self]),[])
			# scope.context.reference
			return ast.c o
			# need to wrap in function



export class While < Loop

	prop test

	def initialize test, opts
		@traversed = no
		@test = test
		@options = opts or {}
		@scope = WhileScope.new(self)
		# set(opts) if opts
		if option(:invert)
			# "invert test for while {@test}"
			@test = test.invert
		# invert the test


	def visit
		scope.visit
		test.traverse if test
		body.traverse if body

	def loc
		var o = @options
		helpers.unionOfLocations(o:keyword,@body,o:guard,@test)

	# TODO BUG -- when we declare a var like: while var y = ...
	# the variable will be declared in the WhileScope which never
	# force-declares the inner variables in the scope

	def consume node

		# This is never expressable, but at some point
		# we might want to wrap it in a function (like CS)
		return super if isExpressable
		var reuse = no
		# WARN Optimization - might have untended side-effects
		# if we are assigning directly to a local variable, we simply
		# use said variable for the inner res
		# if reuse
		# 	resvar = scope.declare(node.left.node.variable,Arr.new([]),proxy: yes)
		# 	node = null
		# 	p "consume variable declarator!?".cyan
		# else
		# declare the variable we will use to soak up results
		# TODO Use a special vartype for this?
		var resvar = scope.declare(:res,Arr.new([]),system: yes)
		# WHAT -- fix this --
		@catcher = PushAssign.new("push",resvar,null) # the value is not preset # what
		body.consume(@catcher) # should still return the same body

		# scope vars must not be compiled before this -- this is important
		var ast = Block.new([self,resvar.accessor]) # should be varaccess instead?
		ast.consume(node)
		# NOTE Here we can find a way to know wheter or not we even need to
		# return the resvar. Often it will not be needed
		# FIXME what happens if there is no node?!?


	def js o
		var out = "while ({test.c(expression: yes)})" + body.c(braces: yes, indent: yes) # .wrap

		if scope.vars.count > 0
			return [scope.vars.c,out]
		out



# This should define an open scope
# should rather
export class For < Loop

	def initialize o = {}
		@traversed = no
		@options = o
		@scope = ForScope.new(self)
		@catcher = null

	def loc
		var o = @options
		helpers.unionOfLocations(o:keyword,@body,o:guard,o:step,o:source)
	
	def ref
		@ref || "{@tag.fragment.cvar}.{oid}"

	def visit stack
		scope.visit

		var parent = stack.@tag

		options[:source].traverse # what about awakening the vars here?
		declare

		# add guard to body
		if options:guard
			var op = IF(options:guard.invert,Block.wrap([ContinueStatement.new("continue")]))
			body.unshift(op,BR)
		
		if parent
			# TODO remove
			@tag = parent
			stack.@tag = self
			@level = (@tag && @tag.@level or 0) + 1

		body.traverse
		stack.@tag = parent
		self

	def isBare src
		src and src.@variable and src.@variable.@isArray

	def declare
		var o = options
		var scope = scope
		var src  = o:source
		var vars = o[:vars] = {}
		var oi   = o:index

		var bare = isBare(src)

		# if the name parameter is array or object we move this inside?

		# what about a range where we also include an index?
		if src isa Range
			
			let from = src.left
			let to = src.right
			let dynamic = from !isa Num or to !isa Num

			if to isa Num
				vars:len = to
			else
				# vars:len = scope.vars.push(vars:index.assignment(src.left))
				# vars:len = to.cache(force: yes, pool: 'len').predeclare
				vars:len = scope.declare('len',to,type: 'let')
				# to.cache(force: yes, pool: 'len').predeclare
				
			# scope.vars.push(vars:index.assignment(src.left))
			vars:value = scope.declare(o:name,from,type: 'let')
			vars:value.addReference(o:name) if o:name
			
			if o:index
				vars:index = scope.declare(o:index,0,type: 'let')
				vars:index.addReference(o:index)
			else
				vars:index = vars:value
				
			if dynamic
				vars:diff = scope.declare('rd',OP('-',vars:len,vars:value),type: 'let')

		else
			if oi
				vars:index = scope.declare(oi,0,type: 'let')
			else
				vars:index = scope.declare('i',Num.new(0),system: yes, type: 'let', pool: 'counter')

			vars:source = bare ? src : scope.declare('items',util.iterable(src),system: yes, type: 'let', pool: 'iter')
			vars:len = scope.declare('len',util.len(vars:source),type: 'let', pool: 'len', system: yes)

			if o:name isa Identifier # also Const etc?
				vars:value = scope.declare(o:name,null,type: 'let')
				vars:value.addReference(o:name) # adding reference!
			elif o:name isa Obj or o:name isa Arr
				vars:value = o:name

			vars:index.addReference(oi) if oi

		return self

	def consume node
		if node isa TagLike
			return node.register(self)

		if isExpressable
			return super

		if @resvar
			var ast = Block.new([self,BR,@resvar.accessor])
			ast.consume(node)
			return ast

		var resvar = null
		var reuseable = no # node isa Assign && node.left.node isa LocalVarAccess
		var assignee = null
		# might only work for locals?
		if node isa Assign
			if var receiver = node.left
				if assignee = receiver.@variable
					# we can only pull the var reference into the scope
					# if we know that the variable is declared in this scope
					reuseable = (receiver isa VarReference)

		resvar = @resvar ||= scope.register(:res,null,system: yes, type: 'var')

		@catcher = PushAssign.new("push",resvar,null) # the value is not preset
		let resval = Arr.new([])
		body.consume(@catcher) # should still return the same body

		if node
			let block = [self,BR,resvar.accessor.consume(node)]

			if @resvar
				block.unshift(BR)
				block.unshift(OP('=',VarReference.new(@resvar,'let'),resval))

			var ast = Block.new(block)
			return ast

		return self

	def js o
		var vars = options:vars
		var idx = vars:index
		var val = vars:value
		var src = options:source
		
		var cond
		var final

		if src isa Range
			let a = src.left
			let b = src.right
			let inc = src.inclusive

			cond = OP(inc ? '<=' : '<',val,vars:len)
			final = OP('++',val)

			if vars:diff
				cond = If.ternary( OP('>',vars:diff,Num.new(0)), cond, OP(inc ? '>=' : '>',val,vars:len))
				final = If.ternary( OP('>',vars:diff,Num.new(0)),OP('++',val),OP('--',val))
			
			if idx and idx != val
				final = ExpressionBlock.new([final,OP('++',idx)])
			
		else
			cond = OP('<',idx,vars:len)
			
			if false and val.refcount < 3 and val.assignments:length == 0 and !val.@noproxy and false
				val.proxy(vars:source,idx)
			elif val isa Obj or val isa Arr
				# should run through an visit? VarReference.new(val,'let')
				body.unshift(OP('=', VarReference.new(val,'let'),OP('.',vars:source,idx)), BR)
			else
				body.unshift(OP('=',val,OP('.',vars:source,idx)), BR)

			if options:step
				final = OP('=',idx,OP('+',idx,options:step))
			else
				final = OP('++',idx)

		var before = ""
		var after = ""

		var code = body.c(braces: yes, indent: yes)
		var head = "{AST.mark(options:keyword)}for ({scope.vars.c}; {cond.c(expression: yes)}; {final.c(expression: yes)}) "
		
		return before + head + code + after



export class ForIn < For

export class ForOf < For
	prop source

	def declare
		var o = options
		var vars = o:vars = {}
		var k
		var v

		# possibly proxy the index-variable?

		if o:own
			vars:source = o:source.@variable || scope.declare('o',o:source, system: true, type: 'let')
			o:value = o:index

			if o:value isa Obj or o:value isa Arr
				vars:value = null
			else
				v = vars:value = scope.declare(o:value,null,let: yes, type: 'let') if o:value

			var i = vars:index = scope.declare('i',Num.new(0),system: yes, type: 'let', pool: 'counter')
			# systemvariable -- should not really be added to the map
			var keys = vars:keys = scope.declare('keys',Util.keys(vars:source.accessor),system: yes, type: 'let') # the outer one should resolve first
			var l = vars:len = scope.declare('l',Util.len(keys.accessor),system: yes, type: 'let')
			k = vars:key = scope.declare(o:name,null,type: 'let') # scope.declare(o:name,null,system: yes)
		else
			# we set the var -- why even declare it
			# no need to declare -- it will declare itself in the loop - no?
			source = vars:source = util.iterable(o:source)
			o:value = vars:value = o:name
			# vars:source = o:source.@variable || scope.temporary(o:source, system: yes, pool: 'dict', type: 'let')
			# vars:source
			# v = vars:value = scope.declare(o:index,null,let: yes, type: 'let') if o:index
			# k = vars:key = scope.register(o:name,o:name,type: 'let')

		# TODO use util - why add references already? Ah -- this is for the highlighting
		v.addReference(o:index) if v and o:index
		k.addReference(o:name) if k and o:name

		self

	def js o
		var vars = options:vars
		var osrc = options:source
		var src = vars:source
		var k = vars:key
		var v = vars:value
		var i = vars:index

		var code

		if options:own
			unless v
				let ref = VarReference.new(options:value,'let')
				body.unshift(OP('=',ref,OP('.',src,k)))
			elif v and v.refcount > 0
				body.unshift(OP('=',v,OP('.',src,k)))

			body.unshift(OP('=',k,OP('.',vars:keys,i)))
			code = body.c(indent: yes, braces: yes) # .wrap
			var head = "{AST.mark(options:keyword)}for ({scope.vars.c}; {OP('<',i,vars:len).c}; {OP('++',i).c})"
			return head + code

		else
			# if v and v.refcount > 0
			# 	body.unshift(OP('=',v,OP('.',src,k)))
			code = scope.c(braces: yes, indent: yes)
			# let inCode = osrc.@variable ? src : (OP('=',src,osrc))
			# it is really important that this is a treated as a statement
			"{AST.mark(options:keyword)}for ({o.es5 ? 'var' : 'let'} {v.c} of {src.c(expression: yes)})" + code

	def head
		var v = options:vars

		[
			OP('=',v:key,OP('.',v:keys,v:index))
			OP('=',v:value,OP('.',v:source,v:key)) if v:value
		]

# NO NEED?
export class Begin < Block


	def initialize body
		@nodes = AST.blk(body).nodes


	def shouldParenthesize
		isExpression



export class Switch < ControlFlowStatement


	prop source
	prop cases
	prop fallback


	def initialize a,b,c
		@traversed = no
		@source = a
		@cases = b
		@fallback = c


	def visit
		c.traverse for c in cases
		fallback.visit if fallback
		source.visit if source
		return


	def consume node
		# TODO work inside tags (like loops)
		@cases = @cases.map(|item| item.consume(node))
		@fallback = @fallback.consume(node) if @fallback
		self

	def c o
		if stack.isExpression or isExpression
			var ast = CALL(FN([],[self]),[])
			return ast.c o

		super.c(o)


	def js o
		var body = []

		for part in cases
			part.autobreak
			body.push(part)

		if fallback
			body.push("default:\n" + fallback.c(indent: yes))

		"switch ({source.c}) " + helpers.bracketize(AST.cary(body).join("\n"),yes)



export class SwitchCase < ControlFlowStatement


	prop test
	prop body


	def initialize test, body
		@traversed = no
		@test = test
		@body = AST.blk(body)
		@scope = BlockScope.new(self)

	def visit
		scope__.visit
		body.traverse

	def consume node
		body.consume(node)
		self


	def autobreak
		body.push(BreakStatement.new) unless body.last isa BreakStatement
		self


	def js o
		@test = [@test] unless @test isa Array
		var cases = @test.map do |item| "case {item.c}: "
		cases.join("\n") + body.c(indent: yes, braces: yes)



export class Try < ControlFlowStatement


	prop body
	# prop ncatch
	# prop nfinally

	def initialize body, c, f
		@traversed = no
		@body = AST.blk(body)
		@catch = c
		@finally = f


	def consume node
		@body = @body.consume(node)
		@catch = @catch.consume(node) if @catch
		@finally = @finally.consume(node) if @finally
		self


	def visit
		@body.traverse
		@catch.traverse if @catch
		@finally.traverse if @finally
		# no blocks - add an empty catch


	def js o
		var out = "try " + body.c(braces: yes, indent: yes)
		out += " " + @catch.c if @catch
		out += " " + @finally.c if @finally

		unless @catch or @finally
			out += " catch (e) \{ \}"
		out += ";"
		out



export class Catch < ControlFlowStatement

	prop body

	def initialize body, varname
		@traversed = no
		@body = AST.blk(body or [])
		@scope = CatchScope.new(self)
		@varname = varname
		self

	def consume node
		@body = @body.consume(node)
		self


	def visit
		@scope.visit
		@variable = @scope.register(@varname,self,pool: 'catchvar')
		@body.traverse


	def js o
		# only indent if indented by default?
		"catch ({@variable.c}) " + @body.c(braces: yes, indent: yes)


# repeating myself.. don't deal with it until we move to compact tuple-args
# for all astnodes


export class Finally < ControlFlowStatement

	def initialize body
		@traversed = no
		@body = AST.blk(body or [])


	def visit
		@body.traverse


	def consume node
		# swallow silently
		self


	def js o
		"finally " + @body.c(braces: yes, indent: yes)


# RANGE

export class Range < Op

	def inclusive
		op == '..'

	def c
		"range"


export class Splat < ValueNode

	def js o
		return "...{value.c}"

		var par = stack.parent
		if par isa ArgList or par isa Arr
			"Array.from({value.c})"
		else
			p "what is the parent? {par}"
			"SPLAT"

	def node
		value





# TAGS

var TAG_TYPES = {}
var TAG_ATTRS = {}

TAG_TYPES.HTML = "a abbr address area article aside audio b base bdi bdo big blockquote body br
 button canvas caption cite code col colgroup data datalist dd del details dfn
 div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6
 head header hr html i iframe img input ins kbd keygen label legend li link
 main map mark menu menuitem meta meter nav noscript object ol optgroup option
 output p param pre progress q rp rt ruby s samp script section select small
 source span strong style sub summary sup table tbody td textarea tfoot th
 thead time title tr track u ul var video wbr".split(" ")
 
TAG_TYPES.HTML_OPT = "abbr address area article aside audio b base bdi bdo big blockquote body br
 button canvas caption cite code col colgroup dd del details dfn
 div dl dt em embed fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6
 head header hr html i img ins kbd keygen label legend li link
 main mark meta meter nav noscript object ol optgroup option
 output p param pre q rp rt ruby s samp script section small
 source span strong style sub summary sup table tbody td tfoot th
 thead time title tr track u ul wbr".split(" ")

TAG_TYPES.SVG = "circle defs ellipse g line linearGradient mask path pattern polygon polyline
radialGradient rect stop svg text tspan".split(" ")

TAG_ATTRS.HTML = "accept accessKey action allowFullScreen allowTransparency alt async
 autoComplete autoFocus autoPlay cellPadding cellSpacing charSet checked
 className cols colSpan content contentEditable contextMenu controls coords
 crossOrigin data dateTime defer dir disabled download draggable encType form
 formNoValidate frameBorder height hidden href hrefLang htmlFor httpEquiv icon
 id label lang list loop max maxLength mediaGroup method min multiple muted
 name noValidate pattern placeholder poster preload radioGroup readOnly rel
 required role rows rowSpan sandbox scope scrollLeft scrolling scrollTop
 seamless selected shape size span spellCheck src srcDoc srcSet start step
 style tabIndex target title type useMap value width wmode"

TAG_ATTRS.SVG = "cx cy d dx dy fill fillOpacity fontFamily fontSize fx fy gradientTransform
 gradientUnits markerEnd markerMid markerStart offset opacity
 patternContentUnits patternUnits points preserveAspectRatio r rx ry
 spreadMethod stopColor stopOpacity stroke strokeDasharray strokeLinecap
 strokeOpacity strokeWidth textAnchor transform version viewBox x1 x2 x y1 y2 y"

export class TagPart < Node

	prop name
	prop value
	
	def initialize value, owner
		@name = value
		@tag = owner
		@chain = []
		@special = no
		self
		
	def isSpecial
		@special
		
	def visit
		@chain.map(|v| v.traverse )
		@value.traverse if @value
		@name.traverse if @name:traverse
		self
	
	def quoted
		@quoted ||= helpers.singlequote(@name)
		
	def isStatic
		!value or value.isPrimitive

	def isProxy
		false
		
	def add item, type
		if type == TagArgList
			@last.params = item
		else
			@chain.push(@last = TagModifier.new(item))
		return self
		
	def js
		""

	def ref
		"c$.{oid}"

export class TagId < TagPart

	def js
		"id={quoted}"
		# "set('id',{quoted})"

export class TagFlag < TagPart
	prop condition

	def value
		@name

	def isStatic
		!isConditional

	def isConditional
		!!condition

	def quoted
		@quoted ||= helpers.singlequote(value)

	def js
		condition ? "flagIf$({quoted},{condition.c})" : "flag$({quoted})"

export class TagFlagExpr < TagFlag
		
	def isStatic
		(!value or value.isPrimitive) and !isConditional
	
	def js
		"setFlag$({value.c})"
	
export class TagSep < TagPart
	
export class TagArgList < TagPart
	
export class TagAttr < TagPart

	def isSpecial
		String(@name) == 'value'

	def visit
		@chain.map(|v| v.traverse )
		@value.traverse if @value
		@name.traverse if @name:traverse

		let key = @key = String(@name)
		let i = key.indexOf(':')

		if i >= 0
			@ns = key.slice(0,i)
			@key = key.slice(i + 1)

		if @chain:length
			@mods = {}
			for m in @chain
				@mods[m.name] = 1
		self

	def ns
		@ns

	def key
		@key

	def mods
		@mods

	def js o
		let mods = AST.compileRaw(@mods or null)
		let val = value.c(o)
		let bval = val
		if ns == 'css'
			"css$('{key}',{val})"
		elif ns == 'bind'
			let path = PATHIFY(value)

			if path isa Variable
				let getter = "function()\{ return {val} \}"
				let setter = "function(v$)\{ {val} = v$ \}"
				bval = "\{get:{getter},set:{setter}\}"
			elif path isa Array
				bval = "[{val[0].c(o)},{val[1].c(o)}]"

			"bind$('{key}',{mods},{bval})"
		elif ns
			# should be setPath instead?
			"setNestedAttr('{ns}','{key}',{val}{add})"
		elif key.indexOf("aria-") == 0
			"setAttribute('{key}',{val})"
		elif key.indexOf("data-") == 0
			"dataset.{key.slice(5)}={val}"
		else
			"{helpers.dashToCamelCase(key)}={val}"
		# elif dyn or true
		# 	"set({quoted},{val}{add})"
		# else
		# 	"{helpers.setterSym(name)}({val}{add})"
	
export class TagAttrValue < TagPart
	
	def isPrimitive
		value.isPrimitive

	def value
		name

	def js
		value.c

	def toRaw
		if value isa Str
			return value.raw
		return null

export class TagHandlerSpecialArg < ValueNode
	def isPrimitive
		yes

	def c
		"'~@{value}'"

export class TagDynamicArg < ValueNode
	def isPrimitive
		yes

	def c
		"'~${value}'"
	
export class TagModifier < TagPart	
	prop params
	
	def isPrimitive
		!params or params.every do |param| param.isPrimitive
			
	def visit
		@params.traverse if @params

		for param in @params when param isa VarOrAccess
			if param.value isa GlobalVarAccess
				let special = TagHandlerSpecialArg.new(param.value.c)
				@params.swap(param,special)
		self
		
	def js
		if params and params.count > 0
			"[{quoted},{params.c}]"
		elif params
			"[{quoted}]"
		else
			quoted

export class TagData < TagPart
	
	def value
		name

	def isStatic
		!value or value.isPrimitive
	
	def isSpecial
		true

	def isProxy
		proxyParts isa Array

	def proxyParts
		var val = value

		if val isa ArgList
			val = val.values[0]
			
		if val isa Parens
			val = val.value
		
		if val isa VarOrAccess
			val = val.@variable or val.value
		# console.log "TagData value {val}"

		if val isa Access
			let left = val.left
			let right = val.right isa Index ? val.right.value : val.right
			
			if val isa IvarAccess
				left ||= val.scope__.context
			
			return [left,right]
		return val

	def js
		var val = value

		if val isa ArgList
			val = val.values[0]
			
		if val isa Parens
			val = val.value
		
		if val isa VarOrAccess
			val = val.@variable or val.value
		# console.log "TagData value {val}"

		if val isa Access
			let left = val.left
			let right = val.right isa Index ? val.right.value : val.right
			
			if val isa IvarAccess
				left ||= val.scope__.context
			
			let pars = [left.c,right.c]
				
			if right isa Identifier
				pars[1] = "'" + pars[1] + "'"

			"bind$('data',[{pars.join(',')}])"
		else
			"data=({val.c})"

export class TagHandler < TagPart
		
	def isStatic
		let valStatic = !value or value.isPrimitive or (value isa Func and !value.nonlocals)
		valStatic and @chain.every(do |item|
			let val = item isa Parens ? item.value : item
			val isa Func ? !val.nonlocals : val.isPrimitive
		)

	def extractDynamicParts
		var dynamics = []
		for part in @chain when part isa TagModifier
			for param in part.params
				if !param.isPrimitive
					let nr = dynamics.push(param)
					let ref = TagDynamicArg.new(String(nr - 1))
					part.params.swap(param,ref)
		return dynamics
	
	def add item, type
		if type == TagArgList
			@last.params = item or ListNode.new([])

		elif type == TagAttrValue
			# really?
			if item isa Parens
				item = item.value
			
			value = item
			@last = null
		else
			# console.log "TagHandler add",item
			@chain.push(@last = TagModifier.new(item))
		return self
		
	def js o
		let parts = [quoted].concat(@chain)
		let parts = [].concat(@chain)
		let scope = scope__
		# let scopes = scope.root.context.reference(scope).c
		# parts.push(value) if value
		return "on$({quoted},[{AST.cary(parts)}],{scope.context.c})"
		# return "on$({slot},[{AST.cary(parts)}],{scope__.context.c})"


class TagLike < Node

	def initialize o = {}
		@options = o
		@flags = 0
		@tagvars = {}
		setup(o)
		self

	def body
		@body || @options:body

	def value
		@options:value

	def isReactive
		yes

	def setup
		@traversed = no
		@consumed = []
		self

	def root
		@parent ? @parent.root : self

	def register node
		if node isa If
			flag(F.TAG_HAS_BRANCHES)
			node = TagBranchFragment.new(body: node)
		elif node isa Loop
			flag(F.TAG_HAS_LOOPS)
			node = TagLoopFragment.new(body: node.body, value: node)

		elif !(node isa Tag) and !(node isa Str)
			flag(F.TAG_HAS_DYNAMIC_CHILDREN)
			node = TagContent.new(value: node)
		elif node isa Tag
			self
		@consumed.push(node)
		node.@parent = self
		return node

	def flag key
		@flags |= key

	def type
		"frag"

	def unflag key
		@flags = @flags & ~key

	def hasFlag key
		@flags & key

	def isOnlyChild
		isFirstChild && isLastChild

	def isFirstChild
		hasFlag(F.TAG_FIRST_CHILD)

	def isLastChild
		hasFlag(F.TAG_LAST_CHILD)

	def isIndexed
		hasFlag(F.TAG_INDEXED)

	def isCustom
		hasFlag(F.TAG_CUSTOM)

	def hasLoops
		hasFlag(F.TAG_HAS_LOOPS)

	def hasBranches
		hasFlag(F.TAG_HAS_BRANCHES)

	def hasDynamicChildren
		hasFlag(F.TAG_HAS_DYNAMIC_CHILDREN)

	def hasDynamicFlags
		hasFlag(F.TAG_HAS_DYNAMIC_FLAGS)

	def hasNonTagChildren
		hasLoops or hasBranches or hasDynamicChildren

	def tagvar name
		@tagvars[name] ||= scope__.closure.temporary(null,{reuse: yes},"{name}${tagvarprefix}")

	def tagvarprefix
		"{level}"

	def level
		@level

	def parent
		@parent ||= option(:parent)

	def fragment
		@fragment || parent

	def tvar
		@tvar or tagvar('t')

	# built variable
	def bvar
		@bvar or (@parent ? @parent.bvar : tagvar('b'))

	# cache variable
	def cvar
		@cvar or (@parent ? @parent.cvar :  tagvar('c'))

	def vvar do tagvar('v') # value variable
	def kvar do tagvar('k') # key variable

	# for tracking specific changes -- included in end
	# shuold maybe link it with built
	def dvar do tagvar('d') # value variable

	def ref
		@ref || (@cachedRef = "{parent ? parent.cvar : ''}.{oid}")

	def visit stack
		var o = @options
		var scope = @tagScope = scope__
		let prevTag = @parent = stack.@tag
		@level = (@parent && @parent.@level or 0) + 1
		stack.@tag = null

		for part in @attributes
			part.traverse

		stack.@tag = self
		
		if o:key
			o:key.traverse

		visitBeforeBody(stack)

		if body
			body.traverse

		visitAfterBody(stack)

		stack.@tag = @parent

		unless @parent
			@level = 0
			consumeChildren
		self

	def visitBeforeBody
		self

	def visitAfterBody
		self

	def consumeChildren
		return if @consumed:length
		body && body.consume(self)
		let first = @consumed[0]
		let last = @consumed[@consumed:length - 1]

		if first isa TagLike
			first.flag(F.TAG_FIRST_CHILD)

		if last isa TagLike
			last.flag(F.TAG_LAST_CHILD)

		for item in @consumed when item isa TagLike
			item.@parent = self
			item.@level = (@level + 1)
			item.consumeChildren
		self

	def consume node
		if node isa TagLike
			return node.register(self)

		if node isa Variable
			option('assignToVar',node)
			return self

		if node isa Assign
			return OP(node.op,node.left,self)
		elif node isa Op
			return OP(node.op,node.left,self)
		elif node isa Return
			# console.log "return is consuming tag"
			option('return',yes)
			return self
		return self

export class TagContent < TagLike
	
	def vvar
		parent.vvar

	def bvar
		fragment.bvar

	def ref
		fragment.tvar

	def key
		@key ||= "{parent.cvar}.{oid}"

	def js
		let value = self.value
		let parts = []
		let isText = (value isa Str or value isa Num or value isa InterpolatedString)

		if isOnlyChild and (value isa Str or value isa Num)
			return "{bvar} || {ref}.text$({value.c(o)})"

		elif value isa InterpolatedString and isOnlyChild
			value = value.@nodes[0] if value.@nodes:length == 1
			return "({vvar}={value.c(o)},{vvar}==={key} || {ref}.text$({key}={vvar}))"

		else
			parts.push("{vvar}={value.c(o)}")

			if value isa Call
				# mark parent to reset imba.ctx at the end
				parts.unshift("imba.ctx=({key}$ || ({key}$=\{\}))")

			parts.push("{vvar}==={key} || ({key}_ = {ref}.insert$({key}={vvar},{@flags},{key}_))")

		return "(" + parts.join(',') + ')'

export class TagFragment < TagLike

export class TagBranchFragment < TagLike

	def tvar
		parent.tvar

	def js o
		let inserts = []

		for item in @consumed when TagLike
			item.@tvar = tagvar(item.oid + '$')
			inserts.push(item.@tvar)

		var out = body.c(o)
		for item in inserts
			let key = "{cvar}.{item}"
			out += "\n({key}_ = {tvar}.insert$({item},{@flags},{key}_));"
		return out

export class TagLoopFragment < TagLike
	def consumeChildren
		super

		if @consumed:length == 1
			flag(@consumed[0].option(:key) ? F.TAG_KEYED : F.TAG_INDEXED)

	def js o
		# if @tag and @childTags
		let iref = LIT('imba.createFragment')
		# should know how many inner slots this fragment has?
		let cache = parent.cvar
		let out = ""
		out += "{tvar} = {cache}.{oid} || ({cache}.{oid} = {tvar} = {iref}({@flags},{parent.tvar}));\n"
		@ref = "{tvar}"
		out += "{kvar} = 0;\n"
		out += "{cvar}={tvar}.$;\n"
		out += value.c(o)
		out += ";{tvar}.end$({kvar})"
		return out

export class TagIndexedFragment < TagLike

export class TagKeyedFragment < TagLike

export class TagSlotProxy < TagLike

	def tagvarprefix
		oid+'S'

export class Tag < TagLike	
	prop attrmap

	def setup
		super
		@attributes = @options:attributes or []
		@attrmap = {}
		@classNames = []
		@className = null

	def attrs
		@attributes

	def visitBeforeBody stack
		@options:type && @options:type.traverse

		# Need to potentially resolve tagname to variables first?
		if isSelf or (tagName.indexOf('-') >= 0)
			flag(F.TAG_CUSTOM)

		if attrs:length == 0 && !@options:type
			@options:type = 'fragment'

		@dynamics = []

		@attributes = @attributes.filter do |item|

			if item isa TagFlag and item.isStatic
				@classNames.push(item.value)
				return false

			if !item.isStatic
				@dynamics.push(item)

			return true

		if @classNames:length
			@className = "'{@classNames.join(' ')}'"
		super

	def register node
		node = super(node)
		# should go for any taglike!
		if node isa TagLike and (isCustom and !isSelf)
			let slotKey = node isa Tag ? node.@attrmap:slot : null
			let name = slotKey ? slotKey.value.toRaw : '__'
			let slot = getSlot(name)
			node.@fragment = slot
		return node

	def visitAfterBody stack
		self

	def getSlot name
		@slots ||= {}
		@slots[name] ||= TagSlotProxy.new(parent: self, name: name)

	def addPart part, type
		let attrs = @attributes
		let curr = attrs.CURRENT
		let next = curr

		if type == TagId
			set(id: part)

		if type == TagArgList
			if attrs:length == 0
				set(args: part)
				return self

		if type == TagSep
			next = null

		elif curr isa TagHandler
			curr.add(part,type)

		elif type == TagAttrValue
			if curr isa TagFlag
				curr.condition = part
				flag(F.TAG_HAS_DYNAMIC_FLAGS)

			elif curr
				curr.value = type.new(part)

		elif curr isa TagAttr
			curr.add(part,type)

		elif type == TagData
			let bind = String(self.type) in ['input','textarea','select','button','option']
			curr = TagAttr.new(bind ? 'bind:model' : 'model')
			curr.value = part.first
			attrs.push(curr)
			next = null
		else
			if type isa TagFlagExpr
				flag(F.TAG_HAS_DYNAMIC_FLAGS)

			attrs.push(next = type.new(part,self))

			if next isa TagAttr
				@attrmap[String(next.name)] = next

		if next != curr
			# if curr isa TagFlag and !curr.isStatic
			# 	flag(F.TAG_HAS_DYNAMIC_FLAGS)
			attrs.CURRENT = next
		self

	def type
		@options:type || (@attributes:length == 0 ? :fragment : :div)

	def tagName
		String(@options:type)
		
	def isSelf
		type isa Self or type isa This

	def isSlot
		tagName == 'slot'
		
	def isNative
		type isa TagTypeIdentifier and type.isSimpleNative
	
	def create_
		isFragment ? LIT('imba.createLiveFragment') : LIT('imba.createElement')


	def bodyScope
		let v = (@options:close and @options:close.value)
		v == '->' ? 'open' : (v == '=>' ? 'closed' : null)

	def isReactive
		@parent ? @parent.isReactive : !(scope__ isa RootScope)

	def isFragment
		tagName == 'fragment'

	def js o
		var isExpression = STACK.isExpression

		var head = []
		var out = []
		var foot = []

		var add = do |val|
			if val isa Variable
				val = val.toString
			out.push(val)

		var parent = self.parent
		var fragment = self.fragment

		let typ = isSelf ? "self" : (isFragment ? "'fragment'" : (type.isClass ? type.name : "'" + type.@value + "'"))

		var wasInline = o:inline
		var isReactive = self.isReactive

		var canInline = no
		var shouldEnd = hasFlag(F.TAG_CUSTOM)

		# whether this tag should set a variable indicating
		# whether this was built now or not
		# basically whether we need a reference at all?
		var markWhenBuilt = shouldEnd or hasDynamicFlags or attrs:length
		# when it has any attributes? - but not text or

		var inCondition = parent && parent.option(:condition)

		var params = [
			typ,
			@flags,
			(fragment ? fragment.tvar : 'null'),
			@className or 'null',
			'null',
			scope__.root.sfco.c
		]

		var nodes = body ? body.values : []

		if nodes:length == 1 and nodes[0] isa Str and !isSelf
			params[4] = nodes[0].c
			nodes = []

		if @dynamics:length == 0 and !hasDynamicFlags
			if nodes.every(|v| v isa Tag or v isa Str)
				if !shouldEnd and !hasNonTagChildren and (parent isa Tag)
					canInline = yes

		if isFragment
			params = params.slice(1,3)

		var ctor = "{tvar}={create_}({params.join(',')})"

		if !parent
			@ref = "{tvar}"

			if isSelf
				add "{tvar}=this"
				add "{tvar}.open$()"
				add "{cvar} = ({bvar}={dvar}=1,{tvar}.$) || ({bvar}={dvar}=0,{tvar}.$=\{\})"

			elif isReactive
				let scop = scope__.closure
				# add "{bvar}={dvar}=1"
				add "{tvar}=({bvar}={dvar}=1,{scop.tagCache}.{oid}) || ({bvar}={dvar}=0,{scop.tagCache}.{oid}={ctor})"
				@ref = tvar
				o:inline = yes if isExpression

				if @consumed:length or @dynamics:length
					add "{cvar} = {tvar}.${oid} || ({tvar}.${oid}=\{\})"
			else
				@cvar = tvar
				add "({ctor})"
				option(:inline,canInline = yes)
				o:inline = yes

		else
			if isSlot
				# render the name of the slot 
				let name = @attrmap:name ? @attrmap:name.value.toRaw : '__'
				# add("{tvar}={fragment.root.tvar}.slot$('{name}')")
				add("{vvar}={fragment.root.tvar}.__slots.{name}")
				add("if({vvar})\{ {vvar}.insertInto$({fragment.tvar}) \}")

				if @consumed:length > 0
					# have children
					@tvar = @parent.tvar
					add("if(!{vvar})\{")
					foot.push('}')
				# should not render any attributes
				@attributes = []
				# add("{tvar}.insertInto$({fragment.tvar})")
				# add("{fragment.tvar}.insert$({ref}={tvar},{@flags},{key}_))")
			# this is a functional tag component
			elif option(:args)
				let key = "{cvar}.{oid}"
				add("imba.ctx=({key}$c || ({key}$c=\{\}))")
				let call = CALL(option(:type).toFunctionalType,option(:args))
				add("{tvar}={call.c(o)}")
				add("{tvar}==={ref} || ({key}_ = {fragment.tvar}.insert$({ref}={tvar},{@flags},{key}_))")
				# call the tag - type?

			elif parent isa TagLoopFragment
				# what if we are not reactive at all?

				if option(:key)
					add "{kvar}={option(:key).c}"
					@ref = "{parent.cvar}[{kvar}]"

				elif parent.isIndexed
					@ref = "{parent.cvar}[{parent.kvar}]"

				# if we add our own bvar?
				@bvar = tagvar(:b)
				add "{bvar}={dvar}=1" # only if we have dynamic stuff?
				add "{tvar} = {ref} || ({bvar}={dvar}=0,{ref} = {ctor})"
				@ref = "{tvar}"
				# dont add cvar always!
				@cvar = tagvar(:c)
				add "{cvar}={ref}.${oid} || ({ref}.${oid}=\{\})"

			elif !isReactive
				add "({ctor})"

			elif canInline
				add "{parent.bvar} || ({ctor})"
			else
				let ref = "{cvar}.{oid}"

				if markWhenBuilt
					@bvar = tagvar(:b)
					add "{tvar} = ({bvar}={dvar}=1,{ref}) || ({bvar}={dvar}=0,{ref}={ctor})"
				else
					add "{tvar} = {ref} || ({ref} = {ctor})"
				@ref = tvar

		if @slots
			for own name, slot of @slots
				# TODO Make sure slot is not already used
				add "{slot.tvar} = {tvar}.slot$('{name}',{cvar})"

		let flagsToConcat = []

		for item in @attributes
			if !isReactive
				# buggy
				add "{tvar}.{item.c(o)}"
			elif item.isStatic
				add "{bvar} || ({tvar}.{item.c(o)})"
			else
				let iref = "{cvar}.{item.oid}"

				if item isa TagFlagExpr
					let val = item.value
					# item.value = LIT("{iref}={vvar}")
					add "({vvar}={val.c(o)},{vvar}==={iref}||({dvar}|={F.DIFF_FLAGS},{iref}={vvar}))"
					flagsToConcat.push("({iref}||'')")

				elif item isa TagFlag
					let cond = item.condition
					let val = item.value
					let cref
					let vref

					if cond and !cond.isPrimitive
						cref = "{cvar}.{cond.oid}"
						add "({vvar}=({cond.c(o)}||undefined),{vvar}==={cref}||({dvar}|={F.DIFF_FLAGS},{cref}={vvar}))"

					if val and !(val isa Token) and !val.isPrimitive
						vref = "{cvar}.{val.oid}"
						add "({vvar}={val.c(o)},{vvar}==={vref}||({dvar}|={F.DIFF_FLAGS},{vref}={vvar}))"

					if cref and vref
						flagsToConcat.push("({cref} ? ({vref}||'') : '')")
					elif cref
						flagsToConcat.push("({cref} ? '{val.c}' : '')")
					elif vref
						flagsToConcat.push("({vref}||'')")
					else
						flagsToConcat.push("'{val.c}'")

					# item.value = LIT("{iref}={vvar}")
					# add "({vvar}={val.c(o)},{vvar}==={iref}||({dvar}|={F.DIFF_FLAGS},{iref}={vvar}))"

				elif item isa TagHandler
					let specials = item.extractDynamicParts()
					add "{vvar} = {iref} || ({iref}={ref}.{item.js(o)})"
					for special,i in specials
						# add "{fragment.cvar}.{special.oid}_$ = {special.c(o)}"
						add "{vvar}[{i}]={special.c(o)}"
						# add "{ref}.{special.oid}_$ = {special.c(o)}"
				elif item isa TagAttr and item.ns == 'bind'
					let rawVal = item.value
					let val = PATHIFY(rawVal)
					let mods = AST.compileRaw(item.mods or null)
					shouldEnd = yes
					if val isa Array
						let key = val[1]
						let bval = key isa Literal ? "[null,{key.c(o)}]" : "[]"
						add "{vvar}={iref} || ({iref}={ref}.bind$('{item.key}',{mods},{bval}))"
						for part,i in val
							unless part isa Literal
								add "{vvar}[{i}]={part.c(o)}"
						# add "({vvar}={rawVal.c(o)},{vvar}=={ref}.value || ({iref}={ref}.bind$('{item.key}',{mods},{bval}))"
					elif val isa Variable
						let getter = "function()\{ return {val.c(o)} \}"
						let setter = "function(v$)\{ {val.c(o)} = v$ \}"
						let bval = "\{get:{getter},set:{setter}\}"
						add "{bvar} || {ref}.bind$('{item.key}',{mods},{bval})"

				else
					let val = item.value
					item.value = LIT("{iref}={vvar}")
					add "({vvar}={val.c(o)},{vvar}==={iref} || ({ref}.{item.js(o)}))"

		if flagsToConcat:length or (isSelf && @className)
			flagsToConcat.unshift(@className) if @className
			let meth = isSelf ? 'flagSelf$' : 'flag$'
			let cond = "{dvar}&{F.DIFF_FLAGS}"
			cond = "(!{bvar}||{cond})" if isSelf
			add "({cond} && {tvar}.{meth}({flagsToConcat.join("+' '+")}))"

		# When there is only one value and that value is a static string or num - include it in ctor
		# loop through attributes etc
		# add 

		let count = nodes:length

		for item in nodes
			if item isa Str # static for sure
				# should this not go into a TagLike?
				if isReactive
					add "{bvar} || {tvar}.insert$({item.c(o)})"
				else
					add "{tvar}.insert$({item.c(o)})"
			else
				add item.c(o)

		if parent isa TagLoopFragment
			if parent.isIndexed
				add "{parent.kvar}++"
			else
				add "{parent.ref}.push({tvar},{parent.kvar}++,{kvar})"

		if shouldEnd
			foot.push(isSelf ? "{tvar}.close$({dvar})" : "{tvar}.end$({dvar})")

		if isFragment and parent
			add "{fragment.ref}.insert$({tvar},{@flags})"

		if option(:fragmented)
			add "imba.ctx=null"

		if !parent
			if option(:return)
				foot.push "return {tvar}"
			elif !isReactive or o:inline
				foot.push "{tvar}"

		out = out.concat(foot)

		if o:inline
			o:inline = wasInline
			return '(' + out.join(',\n') + ')'
		o:inline = wasInline
		return out.join(";\n")


export class TagWrapper < ValueNode

	def visit
		if value isa Array
			value.map(|v| v.traverse)
		else
			value.traverse
		self

	def c
		"{scope__.imba.c}.getTagForDom({value.c(expression: yes)})"


# SELECTORS


export class Selector < ListNode

	def initialize list, options
		@nodes = list or []
		@options = options

	def add part, typ
		push(part)
		self

	def isExpressable
		yes

	def visit
		for item in @nodes
			item.traverse unless item isa Token

	def query
		var str = ""
		var ary = []

		for item in nodes
			var val = item.c
			if item isa Token
				ary.push("'" + val.replace(/\'/g,'"') + "'")
			else
				ary.push(val)

		return ary.join(' + ')


	def js o
		var typ = option(:type)
		var q = AST.c(query)
		var imba = scope__.imba.c

		if typ == '%'
			"{imba}.q$({q},{o.scope.context.c(explicit: yes)})" # explicit context
		elif typ == '%%'
			"{imba}.q$$({q},{o.scope.context.c(explicit: yes)})"
		else
			"{imba}.q{typ}({q})"

export class SelectorPart < ValueNode

# DEFER

export class Await < ValueNode

	prop func

	def js o
		return "await {value.c}" if option(:native)
		# introduce a util here, no?
		CALL(OP('.',Util.Promisify.new([value]),'then'),[func]).c

	def visit o
		# things are now traversed in a somewhat chaotic order. Need to tighten
		# Create await function - push this value up to block, take the outer
		value.traverse

		var fnscope = o.up(Func) # do |item| item isa MethodDeclaration or item isa Fun

		if !o.es5
			if fnscope
				set(native: yes)
				fnscope.set(async: yes)
				return self
			else
				# add warning
				# should add as diagnostics - no?
				warn "toplevel await not allowed"

		var block = o.up(Block) # or up to the closest FUNCTION?
		var outer = o.relative(block,1)
		var par = o.relative(self,-1)

		func = AsyncFunc.new([],[])
		# now we move this node up to the block
		func.body.nodes = block.defers(outer,self)
		func.scope.visit

		# if the outer is a var-assignment, we can simply set the params
		if par isa Assign
			par.left.traverse
			var lft = par.left.node
			# Can be a tuple as well, no?
			if lft isa VarReference
				# the param is already registered?
				# should not force the name already??
				# beware of bugs
				func.params.at(0,yes,lft.variable.name)
			else
				par.right = func.params.at(0,yes)
				func.body.unshift(par)
				func.scope.context

		# If it is an advance tuple or something, it should be possible to
		# feed in the paramlist, and let the tuple handle it as if it was any
		# other value

		# CASE If this is a tuple / multiset with more than one async value
		# we need to think differently.

		# now we need to visit the function as well
		func.traverse
		# pull the outer in
		self

export class AsyncFunc < Func

	def initialize params, body, name, target, options
		super(params,body,name,target,options)

	def scopetype do LambdaScope


# IMPORTS
export class ESMSpecifier < Node
	prop alias
	prop name

	def initialize name, alias
		@name = name
		@alias = alias

	def js
		if @alias
			"{@name.c()} as {@alias.c()}"
		else
			"{@name.c()}"


export class ImportSpecifier < ESMSpecifier
export class ExportSpecifier < ESMSpecifier

export class ESMSpecifierList < ListNode
	
	def js
		'{' + super + '}'

export class ImportNamespaceSpecifier < ImportSpecifier

export class ESMDeclaration < Statement
	def initialize keyword, specifiers, source
		setup
		@keyword = keyword
		@specifiers = specifiers
		@source = source

	def isExport
		String(keyword) == 'export'

	def keyword
		@keyword or option(:keyword)

	def js
		if @specifiers and @source
			"{keyword.c} {AST.cary(@specifiers).join(',')} from {@source.c}"
		elif @specifiers
			"{keyword.c} {AST.cary(@specifiers).join(',')}"
		elif @source
			"{keyword.c} {@source.c}"

export class ImportDeclaration < ESMDeclaration

	def js
		if @specifiers and @source
			"{keyword.c} {AST.cary(@specifiers).join(',')} from {@source.c}"
		else
			"{keyword.c} {@source.c}"

	def visit
		return

		var dec = @declarations = VariableDeclaration.new([])

		var src = @source.c
		var m = src.match(/([\w\_\-]+)(\.js|imba)?[\"\']$/)
		@alias = m ? m[1].replace(/[\/\-]/g,'_') + '_$' : 'mod$'
		@alias = @ns && @ns.alias || @alias

		let req = Require.new(@source)
		if @defaults
			req = Util.RequireDefault.new([req])

		@require = dec.add(@alias,req)
		@require.traverse
		# register the default variable
		if @defaults
			let op = OP('.',@require.variable,Identifier.new('default'))
			dec.add(@defaults,op).type = 'import'

		for specifier in @specifiers
			if specifier isa ImportNamespaceSpecifier

				yes
			else
				let name = specifier.alias or specifier.name
				dec.add(name,OP('.',@require.variable,specifier.name)).type = 'import'

		dec.traverse
		self

	def js2
		return @declarations.c
		return "/*imports*/"


export class ExportDeclaration < ESMDeclaration

# def js
# 	if @source
# 		"{keyword} {@specifiers.c} from {@source.c}"

export class ExportAllDeclaration < ExportDeclaration
export class ExportNamedDeclaration < ExportDeclaration


export class ImportStatement < Statement
	prop ns
	prop imports
	prop source
	
	def self.parse str, startPos = 0
		var named = []
		
		let pos = startPos
		if str[0] == '{'
			pos += 1
			str = str.slice(1,-1)

		var parts = str.trim.split(",") # /\s*,\s*/

		
		
		let id = do |name,loc = 0|
			# slow
			while name[0] == ' '
				loc++
				name = name.substr(1)
			name = name.trim
			Identifier.new(Token.new('IDENTIFIER',name,loc,name:length))
		
		for part in parts
			let asIdx = part.indexOf(" as ")
			if asIdx > 0
				var [name,value] = part.split(" as ")
				named.push([id(name,pos),id(value,pos + asIdx + 4)])
			else
				named.push([id(part,pos)])
			pos += part:length + 1
		return named
		

	def initialize imports, source, ns
		@traversed = no
		@imports = imports
		@source = source
		@ns = ns
		
		if imports and imports.@type == 'IMPORTS'
			@imports = ImportStatement.parse(imports.@value,imports.@loc)
			# console.log "parsed imports",imports.@value,imports.@loc
		elif imports isa Array
			@imports = imports.map(|item| [item])
		self

	def visit
		if @ns
			@nsvar ||= scope__.register(@ns,self)
		else
			var src = source.c
			var m = src.match(/(\w+)(\.js|imba)?[\"\']$/)
			@alias = m ? m[1] + '$' : 'mod$'

		# should also register the imported items, no?
		if @imports
			var dec = @declarations = VariableDeclaration.new([])

			if @imports:length == 1
				let extName = @imports[0][0]
				@alias = @imports[0][1] or extName
				dec.add(@alias,OP('.',Require.new(source),extName)).type = 'import'
				dec.traverse
				return self

			# @declarations = VariableDeclaration.new([])
			@moduledecl = dec.add(@alias,Require.new(source))
			@moduledecl.traverse


			if @imports:length > 1
				for imp in @imports
					let name = imp[1] or imp[0]
					dec.add(name,OP('.',@moduledecl.variable,imp[0])).type = 'import'
			dec.traverse
		self


	def js o

		if @declarations
			return @declarations.c

		var req = Require.new(source)

		if @ns
			# must register ns as a real variable
			return "var {@nsvar.c} = {req.c}"

		if @imports

			var src = source.c
			var alias = []
			var vars = VarBlock.new([])

			if var fname = src.match(/(\w+)(\.js|imba)?[\"\']$/)
				alias.push(fname[1])

			# var alias = src.match(/(\w+)(\.js|imba)?[\"\']$/)
			# create a require for the source, with a temporary name?
			var out = [req.cache(names: alias).c]

			for imp in @imports
				# we also need to register these imports as variables, no?
				var o = OP('=',imp,OP('.',req,imp))
				out.push("var {o.c}")

			return out
		else
			return req.c

	def consume node
		return self


# EXPORT

export class ExportStatement < ValueNode

	def js o
		var nodes = @value.map do |arg| "module.exports.{arg.c} = {arg.c}"

		if nodes:length > 1 and up isa Return
			return '[' + nodes.join(',') + ']'

		else
			return nodes.join(';\n') + ';'

export class Export < ValueNode

	def addExpression expr
		value = value.addExpression(expr)
		return self
		
	def loc
		let kw = option(:keyword)
		kw and kw:region ? kw.region : super

	def consume node
		if node isa Return
			option('return',yes)
			return self
		super
		
	def visit
		value.set(export: self, return: option(:return), default: option(:default))
		super

	def js o
		# p "Export {value}"
		# value.set export: self, return: option(:return), default: option(:default)

		# if value isa VarOrAccess
		# 	return "exports.{value.c} = {value.c};"

		if value isa ListNode
			value.map do |item| item.set export: self

		return value.c

export class Require < ValueNode

	def js o
		var out = value isa Parens ? value.value.c : value.c
		out == 'require' ? 'require' : "require({out})"

export class EnvFlag < ValueNode

	def raw
		@raw ?= STACK.env("" + @value)

	def isTruthy
		var val = raw
		return !!val if val !== undefined
		return undefined

	def loc
		[0,0]

	def c
		var val = raw
		if val !== undefined
			if val isa String
				if val.match(/^\d+(\.\d+)?$/)
					parseFloat(val)
				else
					"'{val}'"
			else
				"{val}"

		else
			"ENV_{@value}"


# UTILS

export class Util < Node

	prop args

	def initialize args
		@args = args

	# this is how we deal with it now
	def self.extend a,b
		Util.Extend.new([a,b])

	def self.callImba scope, meth, args
		CALL(OP('.',scope.imba,Identifier.new(meth)),args)

	def self.repeat str, times
		var res = ''
		while times > 0
			if times % 2 == 1
				res += str
			str += str
			times >>= 1
		return res



	def self.keys obj
		var l = Const.new("Object")
		var r = Identifier.new("keys")
		CALL(OP('.',l,r),[obj])

	def self.len obj, cache
		var r = Identifier.new("length")
		var node = OP('.', obj, r)
		node.cache(force: yes, pool: 'len') if cache
		return node

	def self.indexOf lft, rgt
		var node = Util.IndexOf.new([lft,rgt])
		# node.cache(force: yes, type: 'iter') if cache
		return node

	def self.slice obj, a, b
		var slice = Identifier.new("slice")
		console.log "slice {a} {b}"
		return CALL(OP('.',obj,slice),AST.compact([a,b]))

	def self.iterable obj, cache
		var node = Util.Iterable.new([obj])
		node.cache(force: yes, pool: 'iter') if cache
		return node

	def self.counter start, cache
		# should it not rather be a variable?!?
		var node = Num.new(start) # make sure it really is a number
		node.cache(force: yes, pool: 'counter') if cache
		return node

	def self.array size, cache
		var node = Util.Array.new([size])
		node.cache(force: yes, pool: 'list') if cache
		return node

	def self.defineTag type, ctor, supr
		CALL(TAGDEF,[type,ctor,supr])


	def self.defineClass name, supr, initor
		CALL(CLASSDEF,[name or initor,sup])

	def inlineHelpers
		!!OPTS:inlineHelpers

	def name
		'requireDefault$'

	def js
		scope__.root.helper(self,helper)
		"{name}({@args.map(|v| v.c).join(',')})"

export class Util.Extend < Util
	def helper
		'''
		function extend$(target,ext){
			var descriptors = Object.getOwnPropertyDescriptors(ext);
			Object.defineProperties(target.prototype,descriptors);
			// var keys = Object.keys(descriptors);
			// for(const key of keys){ let desc = descriptors[key]; }
			return target;
		};
		'''

	def js o
		# When this is triggered, we need to add it to the top of file?
		scope__.root.helper(self,helper)
		"extend$({AST.compact(AST.cary(args)).join(',')})"

export class Util.IndexOf < Util

	def helper
		'''
		function idx$(a,b){
			return (b && b.indexOf) ? b.indexOf(a) : [].indexOf.call(a,b);
		};
		'''

	def js o
		if inlineHelpers
			scope__.root.helper(self,helper)
			# When this is triggered, we need to add it to the top of file?
			"idx$({args.map(|v| v.c ).join(',')})"
		else
			"{scope__.imba.c}.indexOf({args.map(|v| v.c ).join(',')})"

export class Util.Len < Util

	def helper
		'''
		function len$(a){
			return a && (a.len instanceof Function ? a.len() : a.length) || 0;
		};
		'''

	def js o
		# 
		if true # isStandalone
			scope__.root.helper(self,helper)
			# When this is triggered, we need to add it to the top of file?
			"len$({args.map(|v| v.c ).join(',')})"
		else
			"{scope__.imba.c}.len({args.map(|v| v.c ).join(',')})"


export class Util.Subclass < Util

	def helper
		# should also check if it is a real promise
		'''
		// helper for subclassing
		function subclass$(obj,sup) {
			for (var k in sup) {
				if (sup.hasOwnProperty(k)) obj[k] = sup[k];
			};
			// obj.__super__ = sup;
			obj.prototype = Object.create(sup.prototype);
			obj.__super__ = obj.prototype.__super__ = sup.prototype;
			obj.prototype.initialize = obj.prototype.constructor = obj;
		};

		'''

	def js o
		scope__.root.helper(self,helper)
		"subclass$({args.map(|v| v.c).join(',')});\n"

export class Util.Promisify < Util

	def helper
		# should also check if it is a real promise
		'''
		function promise$(a){
			if(a instanceof Array){
				console.warn("await (Array) is deprecated - use await Promise.all(Array)");
				return Promise.all(a);
			} else {
				return (a && a.then ? a : Promise.resolve(a));
			}
		}
		'''

	def js o
		if inlineHelpers
			# When this is triggered, we need to add it to the top of file?
			scope__.root.helper(self,helper)
			"promise$({args.map(|v| v.c).join(',')})"
		else
			"{scope__.imba.c}.await({args.map(|v| v.c).join(',')})"

# TODO deprecated: can remove
export class Util.Class < Util

	def js o
		# When this is triggered, we need to add it to the top of file?
		"class$({args.map(|v| v.c).join(',')})"

export class Util.Iterable < Util

	def helper
		# now we want to allow null values as well - just return as empty collection
		# should be the same for for own of I guess
		"function iter$(a)\{ return a ? (a.toIterable ? a.toIterable() : a) : []; \};"

	def js o
		return args[0].c if args[0] isa Arr # or if we know for sure that it is an array

		scope__.root.helper(self,helper)
		return "iter$({args[0].c})"

export class Util.RequireDefault < Util
	
	def helper
		# now we want to allow null values as well - just return as empty collection
		# should be the same for for own of I guess
		'''function requireDefault$(obj){
			return obj && obj.__esModule ? obj : { default: obj };
		};'''

	# function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

export class Util.IsFunction < Util

	def js o
		"{args[0].c}"

export class Util.Array < Util

	def js o
		# When this is triggered, we need to add it to the top of file?
		"new Array({args.map(|v| v.c)})"




class Entities

	def initialize root
		@root = root
		@map = []
		return self

	def add path, object
		@map[path] = object
		unless @map.indexOf(object) >= 0
			@map.push(object)
		self

	def lookup path
		@map[path]

	# def register entity
	# 	var path = entity.namepath
	# 	@map[path] ||= entity
	# 	self

	def plain
		JSON.parse(JSON.stringify(@map))

	def toJSON
		@map

class RootEntities
	
	def initialize root
		@root = root
		@map = {}
		return self

	def add path, object
		@map[path] = object
		self

	def register entity
		var path = entity.namepath
		@map[path] ||= entity
		self

	def plain
		JSON.parse(JSON.stringify(@map))

	def toJSON
		@map
	
# SCOPES

# handles local variables, self etc. Should create references to outer scopes
# when needed etc.

# add class for annotations / registering methods, etc?
# class Interface

# should move the whole context-thingie right into scope
export class Scope

	prop level
	prop context
	prop node
	prop parent
	prop varmap
	prop varpool
	prop params
	prop head
	prop vars
	prop counter
	prop entities

	def p
		if STACK.loglevel > 0
			console.log(*arguments)
		self

	def stack
		STACK

	def initialize node, parent
		@nr = STACK.incr('scopes')
		@head = []
		@node = node
		@parent = parent
		@vars = VariableDeclaration.new([])
		@entities = Entities.new(self)
		@meta = {}
		@annotations = []
		@closure = self
		@virtual = no
		@counter = 0
		@varmap  = {}
		@counters = {}
		@varpool = []
		@refcounter = 0
		@level = (parent ? parent.@level : -1) + 1
		setup
		
	def setup
		@selfless = yes
		
	def incr name = 'i'
		var val = @counters[name] ||= 0
		@counters[name]++
		return val

	def nextShortRef
		AST.counterToShortRef(@refcounter++)

	def meta key, value
		if value != undefined
			@meta[key] = value
			return self
		@meta[key]

	def namepath
		'?'
		
	def tagCache
		# deal with root instead?
		@tagCache ||= declare('c$$',
			# LIT('(Imba.$c ? (Imba.$c[Imba.$k] || (Imba.$c[Imba.$k] = {})) : {})'),
			LIT('(imba.ctx||{})'),
			system: yes
		)
	# def context
	# 	@context ||= ScopeContext.new(self)
		
	def context
		# why do we need to make sure it is referenced?
		unless @context
			if selfless
				@context = parent.context.fromScope(self)
				# @context.reference(self)
			else
				@context = ScopeContext.new(self)
		return @context

	def traverse
		self

	def visit
		return self if @parent
		@parent = STACK.scope(1) # the parent scope
		@level = STACK.scopes:length - 1

		STACK.addScope(self)
		root.scopes.push(self)
		self

	def wrap scope
		@parent = scope.@parent
		scope.@parent = self
		self

	# called for scopes that are not real scopes in js
	# must ensure that the local variables inside of the scopes do not
	# collide with variables in outer scopes -- rename if needed
	def virtualize
		self

	def root
		return STACK.ROOT

		var scope = self
		while scope
			return scope if scope isa RootScope
			scope = scope.parent
		return null

	def register name, decl = null, o = {}
		# FIXME re-registering a variable should really return the existing one
		# Again, here we should not really have to deal with system-generated vars
		# But again, it is important

		if !name
			o:system = yes

		if o:system
			return SystemVariable.new(self,name,decl,o)

		name = helpers.symbolize(name)

		# also look at outer scopes if this is not closed?
		var existing = @varmap.hasOwnProperty(name) && @varmap[name]
		# FIXME check if existing is required to be unique as well?
		return existing if existing and !o:unique
		# var type = o:system ? SystemVariable : Variable
		var item = Variable.new(self,name,decl,o)
		
		# register 
		# if o:type == 'meth' and self isa RootScope
		# 	console.log "add to object",name
		# 	@object.add(name,item)
		# var item = Variable.new(self,name,decl,o)
		# need to check for duplicates, and handle this gracefully -
		# going to refactor later
		@varmap[name] = item if !o:system and !existing
		return item

	def annotate obj
		@annotations.push(obj)
		self

	# just like register, but we automatically
	def declare name, init = null, o = {}
		var variable = name isa Variable ? name : register(name,null,o)
		# TODO create the variabledeclaration here instead?
		# if this is a sysvar we need it to be renameable
		var dec = @vars.add(variable,init)
		variable.declarator ||= dec
		return variable

	
	def reusevar name
		temporary(null,{reuse: yes},name)

	# what are the differences here? omj
	# we only need a temporary thing with defaults -- that is all
	# change these values, no?
	def temporary decl, o = {}, name = null
		if name and o:reuse and @vars["_temp_{name}"]
			return @vars["_temp_{name}"]

		if o:pool
			for v in @varpool
				if v.pool == o:pool && v.declarator == null
					return v.reuse(decl)

		var item = SystemVariable.new(self,name,decl,o)
		
		@varpool.push(item) # It should not be in the pool unless explicitly put there?
		@vars.push(item) # WARN variables should not go directly into a declaration-list
		if name and o:reuse
			@vars["_temp_{name}"] = item
		return item

	def lookup name
		@lookups ||= {}
		var ret = null
		name = helpers.symbolize(name)
		if @varmap.hasOwnProperty(name)
			ret = @varmap[name]
		else
			ret = parent && parent.lookup(name)

			if ret
				@nonlocals ||= {}
				@nonlocals[name] = ret
		ret

	def requires path, name = ''
		root.requires(path,name)

	def imba
		root.imba # requires('imba2', 'Imba')

	def imbaTags
		root.imbaTags
		
	def imbaRef name, shorthand = '_'
		root.imbaRef(name,shorthand)

	def autodeclare variable
		vars.push(variable) # only if it does not exist here!!!

	def free variable
		variable.free # :owner = null
		# @varpool.push(variable)
		self

	def selfless
		!!@selfless

	def closure
		@closure

	def finalize
		self

	def klass
		var scope = self
		while scope
			scope = scope.parent
			return scope if scope isa ClassScope
		return null

	def head
		[@vars,@params]

	def c o = {}
		o:expression = no
		# need to fix this
		node.body.head = head
		var body = node.body.c(o)

	def region
		node.body.region

	def loc
		node.loc

	def dump
		var vars = Object.keys(@varmap).map do |k|
			var v = @varmap[k]
			# unless v.@declarator isa Scope
			# 	console.log v.name, v.@declarator:constructor:name
			# AST.dump(v)
			v.references:length ? AST.dump(v) : null

		var desc =
			nr: @nr
			type: self:constructor:name
			level: (level or 0)
			vars: AST.compact(vars)
			loc: loc

		return desc

	def toJSON
		dump

	def toString
		"{self:constructor:name}"

	def closeScope
		self


# RootScope is wrong? Rather TopScope or ProgramScope
export class RootScope < Scope

	prop warnings
	prop scopes
	prop entities
	prop object
	prop styles
	prop options

	def initialize
		super

		register 'global', self, type: 'global'
		register 'imba', self, type: 'global'
		register 'module', self, type: 'global'
		register 'window', self, type: 'global'
		register 'document', self, type: 'global'
		register 'exports', self, type: 'global'
		register 'console', self, type: 'global'
		register 'process', self, type: 'global'
		register 'parseInt', self, type: 'global'
		register 'parseFloat', self, type: 'global'
		register 'setTimeout', self, type: 'global'
		register 'setInterval', self, type: 'global'
		register 'setImmediate', self, type: 'global'
		register 'clearTimeout', self, type: 'global'
		register 'clearInterval', self, type: 'global'
		register 'clearImmediate', self, type: 'global'
		register 'isNaN', self, type: 'global'
		register 'isFinite', self, type: 'global'
		register '__dirname', self, type: 'global'
		register '__filename', self, type: 'global'
		register '_', self, type: 'global'

		# preregister global special variables here
		@requires = {}
		@warnings = []
		@scopes   = []
		@helpers  = []
		@styles = []
		@selfless = no
		@implicitAccessors = []
		@entities = RootEntities.new(self)
		@object = Obj.wrap({})
		@head = [@vars]

		self.sfco()
		self

	def sfcid
		@sfcid ||= @options:sourcePath and helpers.identifierForPath(@options:sourcePath)
	# single-file-component options
	def sfco
		@sfco ||= declare('sfc$',LIT('{/*$sfc$*/}'))

	def context
		@context ||= RootScopeContext.new(self)

	def globalRef
		let js = "(typeof window !== 'undefined' ? window : (typeof global !== 'undefined' ? global : null))"
		@globalRef ||= declare('global$',LIT(js))

	def lookup name
		name = helpers.symbolize(name)
		@varmap[name] if @varmap.hasOwnProperty(name)

	def visit
		STACK.addScope(self)
		self

	def helper typ, value
		# log "add helper",typ,value
		if @helpers.indexOf(value) == -1
			@helpers.push(value)
			@head.unshift(value)

		return self

	def head
		@head

	def warn data
		# hacky
		data:node = null
		@warnings.push(data)
		self

	def dump
		var obj = {
			warnings: AST.dump(@warnings)
			autoself: @implicitAccessors.map(|s| s.dump)
		}

		if OPTS:analysis:scopes
			var scopes = @scopes.map(|s| s.dump)
			scopes.unshift(super.dump)
			obj:scopes = scopes

		if OPTS:analysis:entities
			obj:entities = @entities

		return obj

	

	# not yet used
	def requires path, name
		if var variable = lookup(name)
			return variable

		if var variable = @requires[name]
			if variable.@requirePath != path
				throw Error.new("{name} is already defined as require('{variable.@requirePath}')")
			return variable

		var req = Require.new(Str.new("'" + path + "'"))
		var variable = Variable.new(self,name,null,system: yes)
		var dec = @vars.add(variable, req)
		variable.declarator ||= dec
		variable.@requirePath = path
		@requires[name] = variable
		return variable

	def imba
		LIT('imba')
		# root.requires('imba2', 'Imba')

	def imbaTags
		return @imbaTags if @imbaTags
		var imbaRef = self.imba
		# don't add if we cannot be certain that imba is required on top
		if @requires.Imba
			@imbaTags = declare('_T',OP('.',imbaRef,'TAGS'))
		else
			@imbaTags = "{imbaRef.c}.TAGS"
			
	def imbaRef name, shorthand = '_'
		if name == 'tagscope'
			name = 'createTagScope(/*SCOPEID*/)'
		elif name == 'tagfactory'
			name = 'createElementFactory(/*SCOPEID*/)'

		var map = @imbaRefs ||= {}
		return map[name] if map[name]

		var imbaRef = self.imba
		
		if @requires.Imba
			map[name] = declare(shorthand,OP('.',imba,name), system: yes)
		else
			map[name] = "{imbaRef.c}.{name}"
		

	def c o = {}
		o:expression = no
		# need to fix this
		node.body.head = head
		var body = node.body.c(o)

		return body

export class ModuleScope < Scope

	def setup
		@selfless = no

	def namepath
		@node.namepath

export class ClassScope < Scope
	
	def setup
		@selfless = no

	def namepath
		@node.namepath

	# called for scopes that are not real scopes in js
	# must ensure that the local variables inside of the scopes do not
	# collide with variables in outer scopes -- rename if needed
	def virtualize
		# console.log "virtualizing ClassScope"
		var up = parent
		for own k,v of @varmap
			v.resolve(up,yes) # force new resolve
		self
		
	def prototype
		@prototype ||= ValueNode.new(OP('.',context,'prototype'))

export class TagScope < ClassScope

export class ClosureScope < Scope

export class FunctionScope < Scope

export class MethodScope < Scope

	def setup
		@selfless = no

export class LambdaScope < Scope

	def context
		# why do we need to make sure it is referenced?
		unless @context
			@context = parent.context.fromScope(self)
		@context


export class FlowScope < Scope

	# these have no params themselves, refer to outer scopes -- hjmm
	def params
		@parent.params if @parent

	def register name, decl = null, o = {}
		if o:type != 'let' and (closure != self)
			if var found = lookup(name)
				if found.type == 'let'
					# p "{name} already exists as a block-variable {decl}"
					# TODO should throw error instead
					decl.warn "Variable already exists in block" if decl
					# root.warn message: "Holy shit"
			closure.register(name,decl,o)
		else
			super(name,decl,o)

	# FIXME should override temporary as well

	def autodeclare variable
		parent.autodeclare(variable)

	def closure
		@parent.closure # this is important?

	def context
		@context ||= parent.context

	def closeScope
		# FIXME
		@context.reference if @context
		self

export class CatchScope < FlowScope

export class WhileScope < FlowScope

	def autodeclare variable
		vars.push(variable)

export class ForScope < FlowScope

	def autodeclare variable
		vars.push(variable)

	def temporary refnode, o = {}, name = null
		parent.temporary(refnode,o,name)

export class IfScope < FlowScope

	def temporary refnode, o = {}, name = null
		parent.temporary(refnode,o,name)

export class BlockScope < FlowScope

	def temporary refnode, o = {}, name = null
		parent.temporary(refnode,o,name)

	def region
		node.region

# lives in scope -- really a node???
export class Variable < Node

	prop scope
	prop name
	prop alias
	prop type
	prop options
	prop initialized
	prop declared
	prop declarator
	prop autodeclare
	prop references
	prop export

	def pool
		null

	def initialize scope, name, decl, o
		@ref = STACK.@counter++
		@c = null
		@scope = scope
		@name  = name
		@alias = null
		@initialized    = yes
		@declarator  	= decl
		@autodeclare 	= no
		@declared		= o and o:declared || no
		@resolved		= no
		@options 		= o || {}
		@type			= o and o:type || 'var' # what about let here=
		@export			= no
		@references 	= [] # only needed when profiling
		@assignments 	= []
		self

	def closure
		@scope.closure

	def assignments
		@assignments

	# Here we can collect lots of type-info about variables
	# and show warnings / give advice if variables are ambiguous etc
	def assigned val, source
		@assignments.push(val)
		if val isa Arr
			# just for testing really
			@isArray = yes
		else
			@isArray = no
		self
	

	def resolve scope = scope, force = no
		return self if @resolved and !force

		@resolved = yes
		var es5 = STACK.es5
		var closure = @scope.closure
		var item = @shadowing or scope.lookup(@name)

		# if this is a let-definition inside a virtual scope we do need
		#
		if @scope != closure and @type == 'let' and (es5 or @virtual) # or if it is a system-variable
			item = closure.lookup(@name)

			# we now need to ensure that this variable is unique inside
			# the whole closure.
			scope = closure

		if item == self
			scope.varmap[@name] = self
			return self

		elif item
			# possibly redefine this inside, use it only in this scope
			# if the item is defined in an outer scope - we reserve the
			if item.scope != scope && (options:let or @type == 'let')
				scope.varmap[@name] = self
				# if we allow native let we dont need to rewrite scope?
				return self if (!es5 and !@virtual and !@shadowing)
					

			# different rules for different variables?
			if @options:proxy
				yes
			else
				var i = 0
				var orig = @name
				# it is the closure that we should use
				while scope.lookup(@name)
					@name = "{orig}{i += 1}"

		scope.varmap[@name] = self
		closure.varmap[@name] = self
		return self

	def reference
		self

	def node
		self

	def cache
		self

	def traverse
		self

	def free ref
		@declarator = null
		self

	def reuse ref
		@declarator = ref
		self

	def proxy par, index
		@proxy = [par,index]
		self

	def refcount
		@references:length

	def c
		return @c if @c
		# options - proxy??
		if @proxy
			@c = @proxy[0].c
			if @proxy[1]
				@c += '[' + @proxy[1].c + ']'
		else
			resolve unless @resolved
			var v = (alias or name)
			@c = typeof v == 'string' ? v : v.c
			# allow certain reserved words
			# should warn on others though (!!!)
			# if @c == 'new'
			# 	@c = '_new'
			# 	# should happen at earlier stage to
			# 	# get around naming conventions
			@c = "{c}$" if RESERVED_REGEX.test(@c) # @c.match(/^(default)$/)
		return @c

	def js
		self.c()

	# variables should probably inherit from node(!)
	def consume node
		return self

	# this should only generate the accessors - not dael with references
	def accessor ref
		var node = LocalVarAccess.new(".",null,self)
		# this is just wrong .. should not be a regular accessor
		# @references.push([ref,el]) if ref # weird temp format
		return node

	def assignment val
		Assign.new('=',self,val)

	def addReference ref
		if ref isa Identifier
			ref.references(self)

		if ref:region and ref.region
			@references.push(ref)
			if ref.scope__ != @scope
				@noproxy = yes

		self

	def autodeclare
		return self if @declared
		@autodeclare = yes
		scope.autodeclare(self)
		@declared = yes
		self

	def predeclared
		@declared = yes
		self


	def toString
		String(name)

	def dump typ
		var name = name
		return null if name[0].match(/[A-Z]/)

		return {
			type: type
			name: name
			refs: AST.dump(@references, typ)
		}


export class SystemVariable < Variable

	def pool
		@options:pool

	# weird name for this
	def predeclared
		scope.vars.remove(self)
		self

	def resolve
		return self if @resolved
		@resolved = yes

		# unless @name
		# adds a very random initial name
		# the auto-magical goes last, or at least, possibly reuse other names
		# "${Math.floor(Math.random * 1000)}"
		var alias = @name
		var typ = @options:pool
		var names = [].concat(@options:names)
		var alt = null
		var node = null

		@name = null

		var scope = self.scope

		if typ == 'tag'
			var i = 0
			while !@name
				var alt = "t{i++}"
				@name = alt unless scope.lookup(alt)

		elif typ == 'iter'
			names = ['ary__','ary_','coll','array','items','ary']

		elif typ == 'dict'
			names = ['dict']

		elif typ == 'val'
			names = ['v_']

		elif typ == 'arguments'
			names = ['$_','$0']

		elif typ == 'keypars'
			names = ['opts','options','pars']

		elif typ == 'counter'
			names = ['i__','i_','k','j','i']

		elif typ == 'len'
			names = ['len__','len_','len']

		elif typ == 'list'
			names = ['tmplist_','tmplist','tmp']
		# or if type placeholder / cacher (add 0)

		if alias
			names.push(alias)

		while !@name && alt = names.pop
			let foundAlt = scope.lookup(alt)
			# check if higher level?
			if !foundAlt # or (foundAlt.scope != scope and type == 'let' and !STACK.es5)
				@name = alt # unless scope.lookup(alt)

		if !@name and @declarator
			if node = declarator.node
				if var nodealias = node.alias
					names.push(nodealias + "_")

		while !@name && alt = names.pop
			@name = alt unless scope.lookup(alt)

		# go through alias proxies
		if alias and !@name
			var i = 0
			@name = alias
			# it is the closure that we should use
			while scope.lookup(@name)
				@name = "{alias}{i += 1}"

		@name ||= "${scope.counter += 1}"
		
		scope.varmap[@name] = self

		if type != 'let' or STACK.es5 or @virtual
			closure.varmap[@name] = self
		self

	def name
		resolve
		@name


export class ScopeContext < Node

	prop scope
	prop value
	prop reference

	def initialize scope, value
		@scope = scope
		@value = value
		@reference = null
		self

	def namepath
		@scope.namepath

	# instead of all these references we should probably
	# just register when it is accessed / looked up from
	# a deeper function-scope, and when it is, we should
	# register the variable in scope, and then start to
	# use that for further references. Might clean things
	# up for the cases where we have yet to decide the
	# name of the variable etc?

	def reference
		# if we are in  constructor we do want to declare it after super
		@reference ||= scope.declare("self",This.new) # {@scope.@level}_

	def fromScope other
		IndirectScopeContext.new(other,self)

	def c
		var val = @value # || @reference
		(val ? val.c : "this")

	def cache
		self
		
	def proto
		"{self.c}.prototype"

export class IndirectScopeContext < ScopeContext
	
	def initialize scope, parent
		@scope = scope
		@parent = parent
		@reference = parent.reference

	def reference
		@reference # parent.reference

	def c
		reference.c


export class RootScopeContext < ScopeContext

	def reference
		# should be a 
		@reference ||= scope.declare("self",scope.object, type: 'global')

	def c o
		# @reference ||= scope.declare("self",scope.object, type: 'global')
		# return "" if o and o:explicit
		var val = reference # @value || @reference
		return (val and val != this) ? val.c : "this"
		# should be the other way around, no?
		# o and o:explicit ? super : ""

export class Super < Node

	def visit
		if var m = STACK.method
			m.set(supr: {node: STACK.blockpart, block: STACK.block})
		self

	def c
		return "super"
		# need to find the stuff here
		# this is really not that good8
		var m = STACK.method
		var out = null
		var up = STACK.current
		var deep = up isa Access

		# TODO optimization for later - problematic if there is a different reference in the end
		if false && m && m.type == :constructor
			out = "{m.target.c}.superclass"
			out += ".apply({m.scope.context.c},arguments)" unless deep
		else
			out = "{m.target.c}.__super__"
			unless up isa Access
				out += ".{AST.c(m.supername)}"
				unless up isa Call # autocall?
					out += ".apply({m.scope.context.c},arguments)"
		out

# constants

export var BR = Newline.new('\n')
export var BR2 = Newline.new('\n\n')
export var SELF = Self.new
# export var SUPER = Super.new

export var TRUE = True.new('true')
export var FALSE = False.new('false')
export var UNDEFINED = Undefined.new
export var NIL = Nil.new

export var ARGUMENTS = ArgsReference.new('arguments')
export var EMPTY = ''
export var NULL = 'null'

export var RESERVED = ['default','native','enum','with']
export var RESERVED_REGEX = /^(default|native|enum|with|new|char)$/

export var UNION = Const.new('union$')
export var INTERSECT = Const.new('intersect$')
export var CLASSDEF = Const.new('imba$class')
export var TAGDEF = Const.new('Imba.TAGS.define')










